<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DRAFT: Demystifying Fourier analysis</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
  <style>
    .example-plot {
      width:800px;
      margin-left: -25px;
    }

    .example-inset-70 {
      width: 850px;
      margin-left: -70px;
    }

    .example-inset-40 {
      width: 820px;
      margin-left: -40px;
    }

    .example-plot svg {
      display: block;
      flex-grow: 1;
      flex-shrink: 0;
    }

    .example-grid {
      display: grid;
      grid-template-columns: auto auto;
      grid-template-rows: auto auto;
    }
    .example-grid > :first-child {
      grid-column: span 2;
    }


    .range-slider {
      display: inline-flex;
      gap: 10px;
      position: relative;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .range-slider input, .range-slider select {
      margin-bottom: 0;
    }

    .range-slider output {
      display: inline-block;
      position: relative;
      min-width: 50px;
      line-height: 20px;
      text-align: center;
      border-radius: 4px;
      background: #F6F8FA;
      padding: 3px 6px;
      margin-left: 8px;
      margin-bottom: 0;
      border: 1px solid #E5E7EB;
      border-bottom: 3px solid #E5E7EB;
      font-size: 0.9rem;
    }
    .range-slider output::after {
      position: absolute;
      top: 8px;
      left: -7px;
      width: 0;
      height: 0;
      border-top: 7px solid transparent;
      border-right: 7px solid #E5E7EB;
      border-bottom: 7px solid transparent;
      content: '';
    }

    .signal-label {
      fill: #546E7A;
      font-size: 0.7rem;
      text-anchor: middle;
    }

    .circle-label {
      fill: #90A4AE;
      font-family: cursive;
      font-size: 0.9rem;
      text-anchor: middle;
    }

    .flex-row {
      display: flex;
      justify-content: space-around;
      align-items: center;
    }

  </style>
  <script>
    const sinusoid = (frequency, phase = 0, amplitude = 1) => (
      (time) => amplitude * Math.sin(2 * Math.PI * frequency * time + phase)
    )

    const combine = (...sinusoids) => (
      (time) => sinusoids.reduce((res, s) => res + s(time), 0)
    )

    const magnitude = ([a, b]) => Math.sqrt(a * a + b * b)

    // generate a single frequency analysis function (naive DFT)
    const analysis = (range, signal) => (freq) => {
      const sine = sinusoid(freq)
      const cosine = sinusoid(freq, Math.PI/2)
      const complex = [0, 0]
      for (const t of range) {
        complex[0] += signal(t) * cosine(t),
        complex[1] -= signal(t) * sine(t)
      }
      return magnitude(complex)
    }


    const createSVG = (width, height) => {
      const svg = d3.create('svg')
      svg
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height])
      return svg
    }

    const color = d3.scaleQuantize().domain([0, 5]).range(['#B0BEC5', '#FFE0B2'])

    const createSignalPlot = ({single} = {}) => {
      const width = 820
      const height = single ? 250 : 320
      const marginLeft = 70
      let result = [0, 0]
      let prevFreq = 0

      const svg = createSVG(width, height)

      const g = svg.insert('g')
        .attr('transform', `translate(${marginLeft}, 30)`)

      const targetPath = g.insert('path')
        .attr('fill', 'none')
        .attr('stroke', '#29B6F6')
        .attr('stroke-width', 2.5)

      svg.append('text')
        .attr('class', 'signal-label')
        .text('target')
        .attr('x', 30)
        .attr('y', 60)

      const sinePath = svg.insert('g')
        .attr('transform', `translate(${marginLeft}, 90)`)
        .insert('path')
          .attr('fill', 'none')
          .attr('stroke', '#E91E63')
          .attr('stroke-width', 1.5)
          .attr('vector-effect', 'non-scaling-stroke')

      const cosinePath = svg.insert('g')
        .attr('transform', `translate(${marginLeft}, 90)`)
        .insert('path')
          .attr('fill', 'none')
          .attr('stroke', '#E91E63')
          .attr('stroke-width', 1.5)
          .attr('vector-effect', 'non-scaling-stroke')

      svg.append('text')
        .attr('class', 'signal-label')
        .text('probe')
        .attr('x', 30)
        .attr('y', 120)

      const sineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(${marginLeft}, 180)`)

      const cosineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(${marginLeft}, 250)`)

      const transformLabel = svg.append('text')
        .attr('class', 'signal-label')
        .text('transform')
        .attr('x', 30)
        .attr('y', 210)

      return {
        svg,
        update: ({targetData, frequency, sineData, cosineData, sineTransformData, cosineTransformData, result}) => {
          const x = d3.scaleLinear().domain([0, targetData.length]).range([0, width-marginLeft])
          const y = d3.scaleLinear().domain([1, -1]).range([0, 50])
          const line = d3.line().curve(d3.curveNatural).x((d, i) => x(i)).y((d) => y(d))
          const area = d3.area().curve(d3.curveNatural).x((d, i) => x(i)).y0(y(0)).y1((d) => y(d))

          targetPath
            .transition()
            .attr('d', line(targetData))

          sinePath.attr('visibility', sineData ? 'visible' : 'hidden')
          cosinePath.attr('visibility', cosineData ? 'visible' : 'hidden')
          transformLabel.attr('y', sineData && cosineData ? 240 : 210)

          // morph from flat line into sine/cosine
          if (frequency == 0 || prevFreq == 0 || prevFreq == frequency) {
            sinePath
              .transition()
              .attr('d', line(sineData ?? []))

            cosinePath
              .transition()
              .attr('d', line(cosineData ?? []))

          // pre-stretch the plot before transitioning to higher frequency
          } else if (frequency > prevFreq) {
            const scale = frequency / prevFreq
            sinePath
              .attr('d', line(sineData ?? []))
              .attr('transform', `scale(${scale} 1)`)
              .transition()
              .attr('transform', `scale(1 1)`)

            cosinePath
              .attr('d', line(cosineData ?? []))
              .attr('transform', `scale(${scale} 1)`)
              .transition()
              .attr('transform', `scale(1 1)`)

          // scale to lower frequency and then modify the path
          } else {
            const scale = prevFreq / frequency
            sinePath
              .transition()
              .attr('transform', `scale(${scale} 1)`)
              .on('end', () => {
                sinePath
                  .attr('transform', `scale(1 1)`)
                  .attr('d', line(sineData ?? []))
              })

            cosinePath
              .transition()
              .attr('transform', `scale(${scale} 1)`)
              .on('end', () => {
                cosinePath
                  .attr('transform', `scale(1 1)`)
                  .attr('d', line(cosineData ?? []))
              })
          }

          sineTransformPath
            .attr('visibility', sineTransformData ? 'visible' : 'hidden')
            .attr('fill', color(Math.abs(result[1])))
            .transition()
            .attr('d', area(sineTransformData ?? []))

          cosineTransformPath
            .attr('visibility', cosineTransformData ? 'visible' : 'hidden')
            .attr('fill', color(Math.abs(result[0])))
            .transition()
            .attr('d', area(cosineTransformData ?? []))

          if (cosineData && !sineData) {
            cosineTransformPath.attr('transform', `translate(${marginLeft}, 180)`)
          }

          prevFreq = frequency
        }
      }
    }

    const createPhaseDemoPlot = ({domain, onPhaseChange}) => {
      const width = 620
      const height = 320
      const marginLeft = 70

      const dragScale = d3.scaleLinear().domain(domain).range([0, width-marginLeft])
      const svg = createSVG(width, height)

      let dragPos = [0, 0]
      const drag = d3.drag()
        .on('drag', (e) => onPhaseChange(dragScale.invert(e.dx)))

      const g = svg.insert('g')
        .attr('transform', `translate(0, 30)`)
        .call(drag)

      g.insert('rect')
        .attr('cursor', 'ew-resize')
        .attr('fill', 'transparent')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', width)
        .attr('height', 60)

      const targetPath = g.insert('path')
        .attr('fill', 'none')
        .attr('stroke', '#29B6F6')
        .attr('stroke-width', 2.5)

      svg.append('text')
        .attr('class', 'signal-label')
        .text('target')
        .attr('x', 30)
        .attr('y', 60)

      const sinePath = svg.insert('g')
        .attr('transform', `translate(0, 90)`)
        .insert('path')
          .attr('fill', 'none')
          .attr('stroke', '#E91E63')
          .attr('stroke-width', 1.5)
          .attr('vector-effect', 'non-scaling-stroke')

      const cosinePath = svg.insert('g')
        .attr('transform', `translate(0, 90)`)
        .insert('path')
          .attr('fill', 'none')
          .attr('stroke', '#E91E63')
          .attr('stroke-width', 1.5)
          .attr('vector-effect', 'non-scaling-stroke')

      svg.append('text')
        .attr('class', 'signal-label')
        .text('probe')
        .attr('x', 30)
        .attr('y', 120)

      const sineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 180)`)
        .attr('fill', '#FFE0B2')

      const cosineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 250)`)
        .attr('fill', '#FFE0B2')

      svg.append('text')
        .attr('class', 'signal-label')
        .text('sine')
        .attr('x', 30)
        .attr('y', 210)

      svg.append('text')
        .attr('class', 'signal-label')
        .text('cosine')
        .attr('x', 30)
        .attr('y', 280)

      return {
        svg,
        update: ({targetData, sineData, cosineData, sineTransformData, cosineTransformData, result}) => {
          const x = d3.scaleLinear().domain([0, targetData.length]).range([marginLeft, width])
          const y = d3.scaleLinear().domain([1, -1]).range([0, 50])

          const line = d3.line().curve(d3.curveNatural).x((d, i) => x(i)).y((d) => y(d))
          const area = d3.area().curve(d3.curveNatural).x((d, i) => x(i)).y0(y(0)).y1((d) => y(d))

          targetPath.attr('d', line(targetData))
          sinePath.attr('d', line(sineData))
          cosinePath.attr('d', line(cosineData))
          sineTransformPath
            .attr('d', area(sineTransformData))
            // .attr('fill', color(Math.abs(result[1])))
          cosineTransformPath
            .attr('d', area(cosineTransformData))
            // .attr('fill', color(Math.abs(result[0])))
        }
      }
    }

    const createUnitCircle = ({enableTransitions} = {enableTransitions:true}) => {
      const width = 180
      const height = 180
      const svg = createSVG(width, height)
      const x = d3.scaleLinear().domain([-65, 65]).range([0, width])
      const y = d3.scaleLinear().domain([65, -65]).range([0, height])

      svg.append('ellipse')
        .attr('cx', x(0))
        .attr('cy', y(0))
        .attr('rx', x(50) - x(0))
        .attr('ry', y(0) - y(50))
        .attr('fill', 'none')
        .attr('stroke', '#B0BEC5')
        .attr('stroke-dasharray', '3 2')

      svg.append('g')
        .attr('transform', `translate(${[0, y(0)]})`)
        .call(d3.axisBottom(x).ticks(2))

      svg.append('text')
        .text('cos')
        .attr('x', x(50))
        .attr('y', y(0))
        .attr('dx', 12)
        .attr('dy', -5)
        .attr('class', 'circle-label')

      svg.append('g')
        .attr('transform', `translate(${[x(0), 0]})`)
        .call(d3.axisLeft(y).ticks(2))
      svg.append('text')
        .text('sin')
        .attr('x', x(0))
        .attr('y', y(50))
        .attr('dy', -5)
        .attr('dx', 12)
        .attr('class', 'circle-label')

      const arcPath = svg.insert('path', 'g')
        .attr('transform', `translate(${[x(0), y(0)]})`)
        .attr('fill', '#FFF3E0')
        .attr('stroke', '#FFCC80')

      const cosBar = svg.append('line')
        .attr('stroke-width', 3)
        .attr('stroke-linecap', 'round')
        .attr('stroke', '#FF9800')
        .attr('x1', x(0))
        .attr('y1', y(0))
        .attr('y2', y(0))

      const sinBar = svg.append('line')
        .attr('stroke-width', 3)
        .attr('stroke-linecap', 'round')
        .attr('stroke', '#FF9800')
        .attr('x1', x(0))
        .attr('y1', y(0))
        .attr('x2', x(0))

      const distance = svg.append('line')
        .attr('stroke-width', 2)
        .attr('stroke-linecap', 'round')
        .attr('stroke', '#FF9800')
        .attr('x1', x(0))
        .attr('y1', y(0))
        .attr('x2', x(0))
        .attr('y2', y(0))

      const arc = d3.arc().innerRadius(0)

      const update = (cos, sin) => {
        const alreadyDrawn = cosBar.attr('x2')

        if (enableTransitions && alreadyDrawn) {
          cosBar.transition().attr('x2', x(cos))
          sinBar.transition().attr('y2', y(sin))
          distance.transition().attr('x2', x(cos)).attr('y2', y(sin))
        } else {
          cosBar.attr('x2', x(cos))
          sinBar.attr('y2', y(sin))
          distance.attr('x2', x(cos)).attr('y2', y(sin))
        }

        const dx = Math.abs(x(cos) - x(0))
        const dy = Math.abs(y(sin) - y(0))

        arc
          .startAngle(Math.PI/2)
          .endAngle(Math.PI/2 - Math.atan2(sin, cos))
          .outerRadius(Math.min(40, 0.8 * Math.sqrt(dx*dx + dy*dy)))

        arcPath.attr('d', arc())

        if (enableTransitions && alreadyDrawn) {
          arcPath
            .attr('opacity', 0)
            .transition()
            .attr('opacity', 1)
        }
      }

      return {
        svg,
        update
      }
    }

    const createFreqBarPlot = ({domain, onBinSelected}) => {
      const height = 200
      const width = 670
      const svg = createSVG(width, height)
      const margin = { top: 20, right: 20, bottom: 30, left: 70 }

      const barBand = d3.scaleBand()
        .range([margin.left, width - margin.right])

      const binBand = d3.scaleBand()
        .range([margin.left, width - margin.right])

      const y = d3.scaleLinear()
        .domain([0, 55])
        .range([height - margin.bottom, margin.top])

      const bars = svg.append('g')

      const xAxis = svg.append('g').attr('transform', `translate(0,${y(0)})`)

      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      const binLines = svg.append('g')
      const bins = svg.append('g')
        .attr('fill', 'transparent')
        .attr('cursor', 'pointer')

      const selectedBin = svg.append('rect')
        .attr('fill', 'transparent')
        .attr('stroke-width', 2)
        .attr('stroke', '#FFA726')
        .attr('y', y(55))
        .attr('height', y(0) - y(55))
        .attr('rx', 3)

      return {
        svg,
        update: (analysis, step, freq) => {
          const range = d3.range(domain[0], domain[1]+step, step)
          const data = range.map(d => analysis(d))

          barBand.domain(range)
          binBand.domain(range)

          xAxis.call(d3.axisBottom(barBand).tickValues(barBand.domain().filter((d) => Number.isInteger(d))))

          bars.selectAll('rect')
            .data(data)
            .join('rect')
              .attr('fill', '#FFE0B2')
              .attr('x', (d,i) => barBand(range[i]) + 0.2 * barBand.bandwidth())
              .attr('y', d => y(d))
              .attr('height', d => y(0) - y(d))
              .attr('width', 0.6 * barBand.bandwidth())

          binLines.selectAll('line')
            .data(range)
            .join('line')
              .attr('stroke', '#B0BEC5')
              .attr('stroke-dasharray', '3 2')
              .attr('x1', d => binBand(d) + binBand.bandwidth())
              .attr('y1', y(0))
              .attr('x2', d => binBand(d) + binBand.bandwidth())
              .attr('y2', y(55))

          bins.selectAll('rect')
            .data(range)
            .join('rect')
              .attr('x', d => binBand(d))
              .attr('y', y(55))
              .attr('height', y(0) - y(55))
              .attr('width', binBand.bandwidth())
              .on('click', (event, d) => onBinSelected(d))

          const transition = selectedBin.attr('x')
            ? selectedBin.transition().duration(150)
            : selectedBin

          transition
            .attr('width', binBand.bandwidth())
            .attr('x', binBand(freq) ?? binBand(0))
        }
      }
    }

    const createLinePlot = ({step, domain}) => {
      const width = 800
      const height = 200
      const svg = createSVG(width, height)

      const margin = { top: 20, right: 30, bottom: 30, left: 40 }
      const range = d3.range(domain[0], domain[1]+step, step)

      const x = d3.scaleLinear()
        .range([margin.left, width - margin.right])
        .domain(domain)

      const y = d3.scaleLinear()
        .domain([1.5, -1.5])
        .range([margin.top, height - margin.bottom])

      svg.append('defs').append('clipPath')
        .attr('id', 'clip')
        .append('rect')
        .attr('x', margin.left)
        .attr('y', -10)
        .attr('width', width - margin.right - margin.left)
        .attr('height', height)

      const xAxis = svg.append('g')
        .attr('transform', `translate(0,${y(0)})`)

      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      const line = d3
        .line()
        .curve(d3.curveNatural)
        .x(x)

      const linePath = svg.insert('path', 'g')
        .datum(range)
        .attr('clip-path', 'url(#clip)')
        .attr('fill', 'none')
        .attr('stroke', '#29B6F6')
        .attr('stroke-width', 1.5)
        .attr('vector-effect', 'non-scaling-stroke')

      return {
        svg,
        update: ({func, domain}) => {
          line.y((d) => y(func(d)))
          const scaledX = d3.scaleLinear()
            .domain(domain)
            .range([margin.left, width-margin.right])
          line.x(scaledX)
          linePath.transition().attr('d', line)
          xAxis.transition().call(d3.axisBottom(scaledX))
        }
      }
    }

    const createAreaPlot = ({domain}) => {
      const width = 800
      const height = 200
      const svg = createSVG(width, height)

      const margin = { top: 20, right: 30, bottom: 30, left: 40 }
      const x = d3.scaleLinear().range([margin.left, width - margin.right]).domain(domain)
      const y = d3.scaleLinear().range([height - margin.bottom, margin.top])

      const step = 0.01
      const range = d3.range(domain[0], domain[1]+step, step)

      const xAxis = svg.append('g')
        .attr('transform', `translate(0,${y(0)})`)

      const yAxis = svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)

      const area = d3
        .area()
        .curve(d3.curveNatural)
        .x(x)
        .y0(y(0))

      const areaPath = svg.insert('path', 'g').attr('fill', '#7986CB')

      return {
        svg,
        update: ({func, step}) => {
          const result = range.map(func)
          const max = d3.max(result)

          xAxis.call(d3.axisBottom(x).ticks(15))

          y.domain([0, max])
          yAxis.transition().call(d3.axisLeft(y).ticks(5))

          area.y1((t, i) => y(result[i]))
          areaPath
            .transition()
            .attr('d', area(range))
        }
      }
    }

  </script>
</head>

<body>

<h1>DRAFT: Demystifying Fourier analysis</h1>

<p>
<pre>

  * sound - repeating patterns in pressure. oscillations propagated in a medium -> waveform
    - beats - interference pattern between two frequencies

  * decompose complex waveform into sinusoids
    - we can reconstruct any waveform from other periodic waves (summation of sine signals)
    - sinusoids are a good choice because they have nice mathematical properties (they also represent up-and-down motion of pistons on a crankshaft)
    - cannot correctly reproduce discontinuous signals (but good enough when band limited?)
    - sines have no special connection to real-word phenomena -> sound waves are not made out of sines as a real-world phenomena!

    - sine waves periodic and repeat from the beginning every one turn around the circle, 360° or 2π radians

  * Fourier formula
  * DFT formula


  - mechanistic mind
</pre>
</p>



<h2>Probing with a single sinewave - fixed phase </h2>

<p style="text-align: center;">
  <img src="https://i.imgflip.com/gkh5g.jpg" alt="Let the probing... Begin!"/>
</p>

<p>probing with a single sinewave with fixed phase, we won't slide it left or right, just change the frequency</p>
<p> https://en.wikipedia.org/wiki/Sine_and_cosine_transforms </p>
<p>the idea is to multiply the signal with a pure sinewave, this basically tells us how closely the signal matches our test sinewave</p>
<p><code> transform = probe &times; target signal </code></p>
<p><code> f(t) * sin(2πft) dt </code></p>

<p>example 4Hz sinewave</p>

<p>
  the resulting transform is the area<br>
  when you sum it together you get a high positive result when the probe highly correlates to the signal,
  for non-matching frequencies the result is zero because troughs and peaks cancel out
  <br>the resulting magnitude and also depends on amplitude of the signal we want to analyze

 </p>

<figure id="example-1" class="example-plot example-inset-70"><!-- interactive demo --></figure>

<div class="range-slider">
  <label style="width:250px">Sine frequency</label>
  <input id="example-1-control" type="range" value=0 min=0 max=8 step=1>
  <output id="example-1-freq"></output>
</div>

<div class="range-slider">
  <label style="width:250px">Target signal amplitude</label>
  <input id="example-1-amplitude" type="range" value=1 min=0 max=2 step=0.2 />
  <output id="example-1-amplitude-label"></output>
</div>
<pre>
  <output id="example-1-result"></output>
</pre>

<script>(() => {
  const domain = [0, 1]
  const step = 0.01
  const range = d3.range(domain[0], domain[1]+step, step)

  const plot = createSignalPlot({single: true})
  document.querySelector('#example-1').appendChild(plot.svg.node())

  const inputFreq = document.getElementById('example-1-control')
  const inputAmp = document.getElementById('example-1-amplitude')
  const inputAmpLabel = document.getElementById('example-1-amplitude-label')
  const freqLabel = document.getElementById('example-1-freq')
  const resultLabel = document.getElementById('example-1-result')

  const drawExample = () => {
    const frequency = Number(inputFreq.value)
    const amplitude = Number(inputAmp.value)
    const targetSignal = sinusoid(4, 0, amplitude)
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    const targetData = range.map((d) => targetSignal(d))
    const sineData = range.map((d) => sine(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const result = d3.fsum(sineTransformData)

    plot.update({
      frequency,
      targetData,
      sineData,
      sineTransformData,
      result: [0, result]
    })

    freqLabel.innerText = `${frequency}Hz`
    inputAmpLabel.innerText = amplitude
    resultLabel.innerText = `sine transform magnitude = ${result.toFixed(2)}`
  }
  d3.selectAll([inputFreq, inputAmp]).on('input', drawExample)
  drawExample()

})()</script>


<h3>Probing and phase</h3>

<p>next we want want to analyze a signal that is still 4Hz but offset by a quarter of a turn (phase π/2) </p>
<p> Why can't we match the signal?
The sine probe is out of phase with the target signal and won't correlate</p>

<p> Let's try moving  our sinewave back also by a quarter of a turn, this now gets us a cosine transform, and it matches
the target wave perfectly  ...notice we're also getting a DC offset, the transform for 0Hz is a replica of the original wave.
in this demo the offset has a magnitude of 1. all the other frequencies we are probing for (analysing) have this same offset.
</p>

<figure id="example-2" class="example-plot example-inset-70"><!-- interactive demo --></figure>

<div class="range-slider">
  <select id="example-2-transform-type">
    <option value="sine">Sine</option>
    <option value="cosine">Cosine</option>
  </select>
  <input id="example-2-freq-input"  type="range" value=0 min=0 max=8 step=1>
  <output id="example-2-freq-label"></output>
</div>
<pre>
  <output id="example-2-result"></output>
</pre>
<script>(() => {
  const domain = [0, 1]
  const step = 0.01
  const range = d3.range(domain[0], domain[1]+step, step)
  const targetSignal = sinusoid(4, Math.PI/2)

  const plot = createSignalPlot({domain: [0, 1], step: 0.01, single: true})
  document.querySelector('#example-2').appendChild(plot.svg.node())

  const typeInput = document.getElementById('example-2-transform-type')
  const freqInput = document.getElementById('example-2-freq-input')
  const freqLabel = document.getElementById('example-2-freq-label')
  const resultLabel = document.getElementById('example-2-result')

  const drawExample = () => {
    const frequency = Number(freqInput.value)

    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    const targetData = range.map((d) => targetSignal(d))
    const sineData = range.map((d) => sine(d))
    const cosineData = range.map((d) => cosine(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])
    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    if (typeInput.value === 'sine') {
      plot.update({
        frequency,
        targetData,
        sineData,
        sineTransformData,
        result,
      })
    } else {
      plot.update({
        frequency,
        targetData,
        cosineData,
        cosineTransformData,
        result,
      })
    }

    freqLabel.innerText = `${frequency}Hz`

    if (typeInput.value === 'sine') {
      resultLabel.innerText = `sine transform magnitude = ${result[1].toFixed(2)}`
    } else {
      resultLabel.innerText = `cosine transform magnitude = ${result[0].toFixed(2)}`
    }
  }

  d3.selectAll([typeInput, freqInput]).on('input', drawExample)
  drawExample()
})()</script>

<br>
<br>

<h3>Probing with sin & cos = Fourier transform</h3>

<p>https://en.wikipedia.org/wiki/Fourier_transform</p>
<p> Let's try combining the sine & cosine transform in our analysis of a 4Hz wave ofset by π/4 (half way between a sine and a cosine)</p>

- we are now dealing with two numbers, which we can show on an 2d xy-plot... you can notice both match partially, from this we can construct a complete match, because
sine waves are periodic and repeat from the beginning every 2π (full turn)... any movement in phase of the sinusoid will reflect in the sine and cosine components

- we don't need any more sinusoids to cover the rest of the quadrants, since the next two sinusoids (apart by π/2) would just be the negatives of our sin/cos probes



<br><code> sin(π) = -sin(0) &  cos(3π/4) = -cos(0)</code>

<p> from the ratio of our sine and cosine matches we can figure out the actual phase and magnitude (as if we were using a sinusoid of that phase).
<p> magnitude is just the length of the diagonal line, which is equal to <code>sqrt(sin<sup>2</sup> + cos<sup>2</sup>) </code></p>

</p>


<figure id="example-3-signal-plot" class="example-plot example-inset-70"><!-- interactive demo --></figure>

<div class="flex-row">
  <div>
    <div class="range-slider">
      <input id="example-3-freq-input"  type="range" value=0 min=0 max=8 step=1>
      <output id="example-3-freq-label"></output>
    </div>
  </div>
  <figure id="example-3-xy-plot"><!-- interactive demo --></figure>
</div>
<pre><output id="example-3-result"></output></pre>

<script>(() => {
  const domain = [0, 1]
  const step = 0.01
  const targetSignal = sinusoid(4, Math.PI/4)
  const range = d3.range(domain[0], domain[1]+step, step)

  const freqInput = document.getElementById('example-3-freq-input')
  const freqLabel = document.getElementById('example-3-freq-label')
  const resultLabel = document.getElementById('example-3-result')

  const plot = createSignalPlot({domain: [0, 1], step: 0.01})
  document.querySelector('#example-3-signal-plot').appendChild(plot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-3-xy-plot').appendChild(circle.svg.node())

  const drawExample = () => {
    const frequency = Number(freqInput.value)

    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    const targetData = range.map((d) => targetSignal(d))
    const sineData = range.map((d) => sine(d))
    const cosineData = range.map((d) => cosine(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])
    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    plot.update({
      targetData,
      sineData,
      cosineData,
      sineTransformData,
      cosineTransformData,
      frequency,
      result,
    })

    circle.update(result[0], result[1])
    freqLabel.innerText = `${frequency}Hz`
    resultLabel.innerText = `transform = [${result[1].toFixed(2)}, ${result[0].toFixed(2)}] \
      \nmagnitude = ${magnitude(result).toFixed(2)}`
  }
  d3.select(freqInput).on('input', drawExample)
  drawExample()
})()</script>

<h3>Phase</h3>

<p>Let's make the frequencies of both the signal under test and our sin/cos probes set at 4Hz and just look at the phase of the signal.
<p><b>Drag</b> the target sine wave left and right. Notice that our sine & cosine probes give a match for any phase in-between</p>

<figure id="example-31" class="example-plot example-inset-70 flex-row"><!-- interactive demo --></figure>

<script>(() => {
  const domain = [0, 1]
  const step = 0.01
  const frequency = 4
  let phase = Math.PI/4
  let targetSignal = sinusoid(frequency, phase)

  const onPhaseChange = (delta) => {
    phase -= delta * 8 * Math.PI
    targetSignal = sinusoid(frequency, phase)
    draw()
  }

  const range = d3.range(domain[0], domain[1]+0.01, 0.01)
  const plot = createPhaseDemoPlot({domain, onPhaseChange})
  document.querySelector('#example-31').appendChild(plot.svg.node())

  const circle = createUnitCircle({enableTransitions: false})
  document.querySelector('#example-31').appendChild(circle.svg.node())

  const sine = sinusoid(frequency)
  const cosine = sinusoid(frequency, Math.PI/2)
  const sineData = range.map((d) => sine(d))
  const cosineData = range.map((d) => cosine(d))

  const draw = () => {
    const targetData = range.map((d) => targetSignal(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])

    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    plot.update({
      targetData,
      sineData,
      cosineData,
      sineTransformData,
      cosineTransformData,
      result
    })

    circle.update(result[0], result[1])
  }
  draw()

})()</script>


<h3>Sin/cos probes and their negatives</h3>

<figure id="example-32" class="example-plot"><!-- interactive demo --></figure>

<script>(() => {

const height = 150
const width = 800
const domain = [0, 1]
const step = 0.01
const frequency = 1
const svg = createSVG(width, height)
const range = d3.range(domain[0], domain[1]+step, step)
const x = d3.scaleLinear().domain(domain).range([30, width-30])
const y = d3.scaleLinear().domain([1, -1]).range([10, height-10])

const line = (func) => d3.line().curve(d3.curveNatural).x(x).y((t) => y(func(t)))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#F06292')
  .attr('stroke-width', 2)
  .attr('d', line(sinusoid(frequency))(range))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#64B5F6')
  .attr('stroke-width', 2)
  .attr('d', line(sinusoid(frequency, Math.PI/2))(range))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#64B5F6')
  .attr('stroke-width', 2)
  .attr('stroke-dasharray', '2 2')
  .attr('d', line(sinusoid(frequency, 1.5*Math.PI))(range))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#F06292')
  .attr('stroke-width', 2)
  .attr('stroke-dasharray', '2 2')
  .attr('d', line(sinusoid(frequency, Math.PI))(range))


document.querySelector('#example-32').appendChild(svg.node())
})()</script>


<h2>Analyzing a complex wave</h2>


Complex signal <code>2Hz + 4Hz + 7Hz</code>
<ul>
  <li> frequency graph with bins shows magnitudes for all probed frequencies</li>
  <li> notice that the 0Hz band for cosine produces an average of the signal</li>
  <li> we introduce a frequency plot that shows a bar for each analysis sinusoid /  probe</li>
  <li> notice that when choosing quarter of Hertz resolution there are spillovers between buckets. at 0.25Hz resolution the 3.75Hz frequency bar appears stronger
  than the 4Hz bar, even though it's a 4Hz component (phase is π)</li>
</ul>


<figure id="example-4" class="example-plot example-grid example-inset-70"><!-- interactive demo --></figure>

<label>Granularity</label>
<select id="example-4-step">
  <option value="1">1Hz</option>
  <option value="0.5">0.5Hz</option>
  <option value="0.25">0.25Hz</option>
</select>


<script>(() => {
  let frequency = 0
  const domain = [0, 1]
  const step = 0.01
  const range = d3.range(domain[0], domain[1]+step, step)

  const onBinSelected = (i) => {
    frequency = i
    drawExample()
  }
  const plot = createSignalPlot()
  document.querySelector('#example-4').appendChild(plot.svg.node())

  const freqPlot = createFreqBarPlot({domain: [0, 8], onBinSelected})
  document.querySelector('#example-4').appendChild(freqPlot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-4').appendChild(circle.svg.node())

  const stepInput = document.querySelector('#example-4-step')

  const components = [
    sinusoid(2, Math.PI/3),
    sinusoid(4, Math.PI, 0.5),
    sinusoid(7, Math.PI/4, 0.25)
  ]
  const targetSignal = combine(...components)

  const drawExample = () => {
    const step = Number(stepInput.value)

    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    const targetData = range.map((d) => targetSignal(d))
    const sineData = range.map((d) => sine(d))
    const cosineData = range.map((d) => cosine(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])
    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    plot.update({
      frequency,
      targetData,
      sineData,
      cosineData,
      sineTransformData,
      cosineTransformData,
      result,
    })

    freqPlot.update(analysis(range, targetSignal), step, frequency)
    circle.update(result[0], result[1])
  }

  d3.select(stepInput).on('input', drawExample)
  drawExample()

})()</script>


<hr />


<h3>Spectral spillover</h3>
<p> what happens if we analyze in-between frequencies</p>
<p> this time we are analyzing only one frequency that's 3.5 Hz with phase π/3 </p>
<p> We can see that for non-integer frequencies we get spill over into adjacent buckets.
we can recognize that the actual peak is somewhere between 4Hz & 5Hz by interpolating.
we can also increase the number of bins by creating more granular sinusoid probes for analyzing</p>

<figure id="example-5" class="example-plot example-grid example-inset-70"><!-- interactive demo --></figure>

<label>Granularity</label>
<select id="example-5-step">
  <option value="1">1Hz</option>
  <option value="0.5">0.5Hz</option>
  <option value="0.25">0.25Hz</option>
</select>


<script>(() => {
  let frequency = 0

  const onBinSelected = (i) => {
    frequency = i
    drawExample()
  }
  const domain = [0, 1]
  const step = 0.01
  const range = d3.range(domain[0], domain[1]+step, step)

  const plot = createSignalPlot()
  document.querySelector('#example-5').appendChild(plot.svg.node())

  const freqPlot = createFreqBarPlot({domain: [0, 8], step: 1, onBinSelected})
  document.querySelector('#example-5').appendChild(freqPlot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-5').appendChild(circle.svg.node())

  const stepInput = document.querySelector('#example-5-step')

  const targetSignal = sinusoid(3.5, Math.PI / 3)

  const drawExample = () => {
    const step = Number(stepInput.value)

    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    const targetData = range.map((d) => targetSignal(d))
    const sineData = range.map((d) => sine(d))
    const cosineData = range.map((d) => cosine(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])
    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    plot.update({
      frequency,
      targetData,
      sineData,
      cosineData,
      sineTransformData,
      cosineTransformData,
      result,
    })
    freqPlot.update(analysis(range, targetSignal), step, frequency)
    circle.update(result[0], result[1])
  }
  d3.select(stepInput).on('input', drawExample)
  drawExample()

})()</script>




<h3>Sinc function & spectral resolution</h3>

<p> <b>2.5Hz</b></p>

<figure id="example-6" class="example-plot example-inset-40"><!-- interactive demo --></figure>

<label>Time window</label>
<select id="example-6-select">
  <option value="1">1s</option>
  <option value="5">5s</option>
  <option value="10">10s</option>
  <option value="30">30s</option>
</select>

<p>
spillover happens because our sine isn't infinite in time and we are analyzing frequencies that are not all periodic with the fixed window.
an infinite sine would give perfect peaks in the spectrum plot, but our sine signal is showing lobes in neighboring frequency bins.
with a finite window we will have many of our probes that are close in frequency give a perceptible match.
that's because they or the signal don't fit perfectly in the window (aren't periodic with it)
and have some scrappy fraying parts near each side of the window.

lobes happen because the transforms don't cancel out when they should, they are sliced off at the ends at the wrong place.
if we had an infinite window of time or we tailored the window to be periodic with each measured frequency and the target signal,
all of this noise would cancel out and leave a pure spike for the probe that fully matches our sinusoid.
</p>


<script>(() => {
  const signal = sinusoid(2.5)
  const step = 0.01

  const plot = createLinePlot({step, domain: [0, 30]})
  document.querySelector('#example-6').appendChild(plot.svg.node())

  const freqPlot = createAreaPlot({domain: [0, 5]})
  document.querySelector('#example-6').appendChild(freqPlot.svg.node())

  const sizeInput = document.getElementById('example-6-select')

  const drawExample = () => {
    const size = Number(sizeInput.value)
    const range = d3.range(0, size+step, step)
    plot.update({domain: [0, size], func: signal})
    freqPlot.update({func: analysis(range, signal)})
  }

  d3.select(sizeInput).on('change', drawExample)
  drawExample()

})()</script>

<h3>Periodic window & fraying ends</h3>

<pre>
  - sinewave 2Hz
  - one sine probe 4Hz
  - window size moved in increments of π
  - notice that when the window size is periodic with the sine transform, we get a perfect cancellation since the 4Hz probe should not match the 2Hz wave
  - we get partial matches when probe sine does not perfectly fit in the window
</pre>


<figure id="example-7" class="example-plot"><!-- interactive demo --></figure>

<div class="range-slider">
  <label>Time window</label>
  <input id="example-7-input" type="range" min="1" max="2" value="1" step="0.125"></input>
  <output id="example-7-label"></output>
</div>

<pre>
  <output id="example-7-result"></output>
</pre>

<script>(() => {
  const targetSignal = sinusoid(2)
  const sine = sinusoid(4)
  const margin = 25
  const width = 800
  const height = 250
  const svg = createSVG(width, height)
  const g = svg.insert('g')
    .attr('transform', `translate(0, 30)`)

  const targetPath = g.insert('path')
    .attr('fill', 'none')
    .attr('stroke', '#29B6F6')
    .attr('stroke-width', 2.5)

  const sinePath = svg.insert('g')
    .attr('transform', `translate(0, 90)`)
    .insert('path')
      .attr('fill', 'none')
      .attr('stroke', '#E91E63')
      .attr('stroke-width', 1.5)
      .attr('vector-effect', 'non-scaling-stroke')

  const sineTransformPath = svg.insert('path', 'g')
    .attr('transform', `translate(0, 180)`)
    .attr('fill', '#B0BEC5')

  const fragmentPath = svg.insert('path', 'g')
    .attr('transform', `translate(0, 180)`)
    .attr('fill', '#FFE0B2')

  const bottomAxis = svg.append('g')
    .attr('transform', `translate(0, 160)`)


  document.querySelector('#example-7').appendChild(svg.node())

  const input = document.getElementById('example-7-input')

  const line = d3.line().curve(d3.curveNatural)
  const area = d3.area().curve(d3.curveNatural)
  const y = d3.scaleLinear().domain([1, -1]).range([0, 50])
  const x = d3.scaleLinear().range([margin, width-margin])

  const axisScale = d3.scaleLinear().range([margin, width-margin])

  const draw = () => {
    const size = Number(input.value)

    const periods = size / 0.25
    document.querySelector('#example-7-label').innerText = `${size}s (${periods} periods)`

    const domain = [0, size]
    const range = d3.range(domain[0], domain[1]+0.01, 0.01)

    const targetData = range.map((d) => [d, targetSignal(d)])
    const sineData = range.map((d) => [d, sine(d)])
    const sineTransformData = range.map((d, i) => [d, sineData[i][1] * targetData[i][1]])

    x.domain(domain)

    line.x((d) => x(d[0])).y((d) => y(d[1]))
    area.x((d) => x(d[0])).y0(y(0)).y1((d) => y(d[1]))

    bottomAxis.call(d3.axisBottom(x).ticks())
    targetPath.attr('d', line(targetData))
    sinePath.attr('d', line(sineData))
    sineTransformPath.attr('d', area(sineTransformData))

    // find non-periodic fragment at the end
    const fragmentLength = (size % 0.25)

    const fragmentData = d3.range(domain[1] - fragmentLength, domain[1] + 0.01, 0.01)
      .map((d) => [d, sine(d) * targetSignal(d)])
    fragmentPath.attr('d', area(fragmentData))

    const result = d3.fsum(sineTransformData.map(d => d[1]))
    document.querySelector('#example-7-result').innerText = `Result: ${result.toFixed(2)}`
  }
  draw()

  d3.select(input).on('input', draw)

})()</script>

<h3>Complex numbers </h3>

<br>

<code> cost(t) - i &times; sin(t)</code>
Just a convenient math way to write sin/cos in a single math expression.

The sine/cosine components need to be presented somehow in a single math expression, ergo multiply sin component by the imaginary number,
because real & imaginary don't mix.

<hr>
<footer>
  Copyright &copy; Davorin Šego
</footer>

</body>
</html>
