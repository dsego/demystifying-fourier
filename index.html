<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Interactive DFT</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="./common.js"></script>
  <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
  <style>
    input[type=range] {
      width: 500px;
    }

    .example-plot {
/*      display: flex;*/
      width:800px;
      margin-left: -25px;
    }

    .example-plot svg {
      display: block;
      flex-grow: 1;
      flex-shrink: 0;
    }
  </style>
  <script>
    const sinusoid = (frequency, phase = 0, amplitude = 1) => (
      (time) => amplitude * Math.sin(2 * Math.PI * frequency * time + phase)
    )

    const combine = (...sinusoids) => (
      (time) => sinusoids.reduce((res, s) => res + s(time), 0)
    )

    const magnitude = ([a, b]) => Math.sqrt(a * a + b * b)


    const createSVG = (width, height) => {
      const svg = d3.create('svg')
      svg
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height])
      return svg
    }

    const color = d3.scaleQuantize().domain([0, 5]).range(['#B0BEC5', '#FFE0B2'])

    const createSignalPlot = ({domain, step}) => {
      const width = 800
      const height = 300
      const svg = createSVG(width, height)

      const targetPath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 30)`)
        .attr('fill', 'none')
        .attr('stroke', '#29B6F6')
        .attr('stroke-width', 3)

      const sinePath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 90)`)
        .attr('fill', 'none')
        .attr('stroke', '#E91E63')
        .attr('stroke-width', 1.5)

      const cosinePath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 90)`)
        .attr('fill', 'none')
        .attr('stroke', '#E91E63')
        .attr('stroke-width', 1.5)

      const sineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 180)`)

      const cosineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 250)`)

      const range = d3.range(domain[0], domain[1]+step, step)
      const x = d3.scaleLinear().domain(domain).range([0, width])
      const y = d3.scaleLinear().domain([1, -1]).range([0, 50])
      const line = (func) => d3.line().curve(d3.curveNatural).x(x).y((t) => y(func(t)))
      const area = (func) => d3.area().curve(d3.curveNatural).x(x).y0(y(0)).y1((t) => y(func(t)))
      let result = [0, 0]

      return {
        svg,
        result: () => result,
        update: ({ targetSignal, sine, cosine, sineTransform, cosineTransform }) => {
          result = [
            d3.fsum(range, (t) => sineTransform(t)),
            cosineTransform ? d3.fsum(range, (t) => cosineTransform(t)) : undefined,
          ]
          targetPath.attr('d', line(targetSignal)(range))
          sinePath.attr('d', line(sine)(range))
          if (cosine) {
            cosinePath.attr('d', line(cosine)(range))
          }
          sineTransformPath
            .attr('d', area(sineTransform)(range))
            .attr('fill', color(Math.abs(result[0])))
          if (cosineTransform) {
            cosineTransformPath
              .attr('d', area(cosineTransform)(range))
              .attr('fill', color(Math.abs(result[1])))
          }
        }
      }
    }


    const createMeter = () => {
      const width = 300
      const height = 50
      const svg = createSVG(width, height)
      const y = d3.scaleLinear().domain([0, 60]).range([height, 0])

      svg.append('g').call(d3.axisLeft(y))

      const bar = svg.append('rect')
        .attr('x', 5)
        .attr('width', 5)
        .attr('fill', '')

      return {
        svg,
        update: (value) => {
          bar
            .attr('y', d => y(value))
            .attr('height', d => y(0) - y(value))
            .attr('fill', color(Math.abs(value)))
        }
      }
    }



    const createUnitCircle = () => {
      const width = 300
      const height = 300
      const svg = createSVG(width, height)
      const x = d3.scaleLinear().domain([-70, 70]).range([0, width])
      const y = d3.scaleLinear().domain([70, -70]).range([0, height])

      svg.append('ellipse')
        .attr('cx', x(0))
        .attr('cy', y(0))
        .attr('rx', x(50) - x(0))
        .attr('ry', y(0) - y(50))
        .attr('fill', 'none')
        .attr('stroke', '#B0BEC5')

      svg.append('g')
        .attr('transform', 'translate(' + [0, y(0)] + ')')
        .call(d3.axisBottom(x))
      // .append('text')
      //   .text('cos')
      //   .attr('x', x(1))
      //   .attr('dy', -6)

      svg.append('g')
        .attr('transform', 'translate(' + [x(0), 0] + ')')
        .call(d3.axisLeft(y))
      // .append('text')
      //   .text('sin')
      //   .attr('transform', 'rotate(-90)')
      //   .attr('y', 15)

      const cosBar = svg.append('line')
        .attr('x1', x(0))
        .attr('y1', y(0))
        .attr('y2', y(0))
        .attr('stroke-width', 3)
        .attr('stroke', '#FFB74D')

      const sinBar = svg.append('line')
        .attr('stroke-width', 3)
        .attr('stroke', '#FFB74D')
        .attr('x1', x(0))
        .attr('y1', y(0))
        .attr('x2', x(0))

      const distance = svg.append('line')
        .attr('stroke-width', 1)
        .attr('stroke', '#FFB74D')
        .attr('x1', x(0))
        .attr('y1', y(0))

      const update = (cos, sin) => {
        cosBar.attr('x2', x(cos))
        sinBar.attr('y2', y(sin))
        distance.attr('x2', x(cos)).attr('y2', y(sin))
      }

      return {
        svg,
        update
      }
    }


    // // plane.body.selectAll('.axis .tick')
    // //   .filter(function (d) { return d === 0 })
    // //   .remove()

    // // https://materialui.co/colors/



    // const step = 1
    // const step = 0.1 //  sinc function :D


    const createFreqPlot = ({ domain, onBinSelected }) => {
      const height = 200
      const width = 800
      const svg = createSVG(width, height)
      const margin = { top: 20, right: 30, bottom: 30, left: 40 }

      const barBand = d3.scaleBand()
        .range([margin.left, width - margin.right])
        .padding(0.5)

      const binBand = d3.scaleBand()
        .range([margin.left, width - margin.right])

      const y = d3.scaleLinear()
        .domain([0, 55])
        .range([height - margin.bottom, margin.top])

      const bars = svg.append('g')
      const bins = svg.append('g').attr('fill', 'transparent')

      const xAxis = svg.append('g')
        .attr('transform', `translate(0,${y(0)})`)

      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      return {
        svg,
        update: (analysis, step) => {
          const range = d3.range(domain[0], domain[1]+step, step)
          barBand.domain(range)
          binBand.domain(range)
          xAxis.call(d3.axisBottom(barBand).tickValues(range))

          bars.selectAll('rect')
            .data(range)
            .join('rect')
              .attr('fill', '#B0BEC5')
              .attr('x', i => barBand(i))
              .attr('y', i => y(analysis(i)))
              .attr('height', i => y(0) - y(analysis(i)))
              .attr('width', barBand.bandwidth())

          bins.selectAll('rect')
            .data(range)
            .join('rect')
              .attr('stroke', '#B0BEC5')
              .attr('stroke-dasharray', '1 3')
              .attr('x', i => binBand(i))
              .attr('y', i => y(55))
              .attr('height', i => y(0) - y(55))
              .attr('width', binBand.bandwidth())
              .on('click', (event, i) => {
                // d3.select(event.target)
                //   .attr('fill', '#FFCC80')
                //   .attr('fill-opacity', 0.5)
                onBinSelected(i)
              })
        }
      }
    }



    const createLinePlot = ({domain, step, func}) => {
      const width = 800
      const height = 300
      const svg = createSVG(width, height)

      const margin = { top: 20, right: 30, bottom: 30, left: 40 }


      const range = d3.range(domain[0], domain[1]+step, step)
      const x = d3.scaleLinear().domain(domain).range([margin.left, width - margin.right])
      const y = d3.scaleLinear().domain([1, -1]).range([margin.top, height - margin.bottom])


      svg.append('g')
        .attr('transform', `translate(0,${y(0)})`)
        .call(d3.axisBottom(x).ticks(5))

      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      const line = d3
        .line()
        .curve(d3.curveNatural)
        .x(x)
        .y((t) => y(func(t)))

      svg.insert('path', 'g')
        .attr('fill', 'none')
        .attr('stroke', '#29B6F6')
        .attr('stroke-width', 1.5)
        .attr('d', line(range))

      return {
        svg
      }
    }

    const createAreaPlot = ({domain, step, func}) => {
      const width = 800
      const height = 300
      const svg = createSVG(width, height)

      const margin = { top: 20, right: 30, bottom: 30, left: 40 }


      const range = d3.range(domain[0], domain[1]+step, step)
      const x = d3.scaleLinear().domain(domain).range([margin.left, width - margin.right])
      const y = d3.scaleLinear().domain([0, 10]).range([height - margin.bottom, margin.top])


      svg.append('g')
        .attr('transform', `translate(0,${y(0)})`)
        .call(d3.axisBottom(x).ticks(15))

      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      const area = d3
        .area()
        .curve(d3.curveNatural)
        .x(x)
        .y0(y(0))
        .y1((t) => y(func(t)))

      svg.insert('path', 'g')
        .attr('fill', '#7986CB')
        .attr('d', area(range))

      return {
        svg
      }
    }

  </script>
</head>

<body>

<h1>DFT</h1>

<p>
<pre>

  * sound - repeating patterns in pressure. oscillations propagated in a medium -> waveform
    - beats - interference pattern between two frequencies

  * decompose complex waveform into sinusoids
    - we can reconstruct any waveform from other periodic waves (summation of sine signals)
    - sinusoids are a good choice because they have nice mathematical properties (they also represent up-and-down motion of pistons on a crankshaft)
    - cannot correctly reproduce discontinuous signals (but good enough when band limited?)
    - sines have no special connection to real-word phenomena -> sound waves are not made out of sines as a real-world phenomena!


  * Fourier formula
  * DFT formula
</pre>
</p>



<h2>Probing</h2>

<img src="https://i.imgflip.com/gkh5g.jpg" />

<p>probing with a single sinewave - fixed phase (Fourier sine transform )</p>
<p> https://en.wikipedia.org/wiki/Sine_and_cosine_transforms </p>

<p><pre> f(t) * sin(2πft) dt </pre></p>

<p>example 4Hz sinewave </p>

<p>
  the resulting transform is the area<br>
  troughs and peaks cancel out -> when you sum it together you get a high positive result when the probe highly correlates to the signal,
  for non-matching frequencies the result is practically zero (is it zero or tiny and negligible?)
  <br> also depends on amplitude of the signal we want to analyze

 </p>

 <p>TODO: add labels on the left side of example:  target function, sine probe function (reflects changing freq) and transform function</p>
 <p>TODO: add another bar plot for frequency (vu meter) - for fourier this becomes a xy plot </p>

<div id="example-1" class="example-plot">
  <!-- interactive demo -->
</div>

<input id="example-1-control" type="range" value=0 min=0 max=10 step=1>
<br>
<span id="example-1-result"></span>

<script>(() => {
  const targetSignal = sinusoid(4)
  const plot = createSignalPlot({domain: [0, 1], step: 0.01})
  document.querySelector('#example-1').appendChild(plot.svg.node())

  const meter = createMeter()
  document.querySelector('#example-1').appendChild(meter.svg.node())

  const input = document.getElementById('example-1-control')
  const resultLabel = document.getElementById('example-1-result')

  const drawExample = () => {
    const frequency = Number(input.value)
    const sine = sinusoid(frequency)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    plot.update({
      targetSignal,
      sine,
      sineTransform,
    })
    const [result, _] = plot.result()
    meter.update(result)
    resultLabel.innerText = `f=${frequency}Hz, sine transform=${result.toFixed(2)} (${result})`
  }
  d3.select(input).on('change', drawExample)
  drawExample()

})()</script>


<h3>Probing and phase</h3>

<p>The signal is still 4Hz but offset by a phase π/2 </p>
<p> Why can't we match the signal?</p>

<p> Let's try using a cosine transform to probe ... notice we're also getting some noise  (non-zero results for non-matching frequencies)
    is it because of hann window??
</p>

<div id="example-2" class="example-plot">
  <!-- interactive demo -->
</div>
<p>
  <label>Probe type</label>
  <select id="example-2-transform-type">
    <option value="sine">Sine</option>
    <option value="cosine">Cosine</option>
  </select>
</p>
<input id="example-2-freq"  type="range" value=0 min=0 max=10 step=1>
<span id="example-2-result"></span>

<script>(() => {
  const targetSignal = sinusoid(4, Math.PI/2)

  const plot = createSignalPlot({domain: [0, 1], step: 0.01})
  document.querySelector('#example-2').appendChild(plot.svg.node())

  const meter = createMeter()
  document.querySelector('#example-2').appendChild(meter.svg.node())

  const typeInput = document.getElementById('example-2-transform-type')
  const freqInput = document.getElementById('example-2-freq')
  const resultLabel = document.getElementById('example-2-result')

  const drawExample = () => {
    const frequency = Number(freqInput.value)
    const sine = typeInput.value === 'sine'
      ? sinusoid(frequency)
      : sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)

    plot.update({
      targetSignal,
      sine,
      sineTransform,
    })
    const [result, _] = plot.result()
    meter.update(result)
    resultLabel.innerText = `f=${frequency}Hz, sine transform=${result.toFixed(2)} (${result})`
  }

  d3.selectAll([typeInput, freqInput]).on('change', drawExample)
  drawExample()
})()</script>

<br>
<br>

<h3>Probing with sin & cos = Fourier transform</h3>

<p> Let's try combining the sine & cosine transform in our analysis</p>

- we are now dealing with two numbers... you can notice both match partially, from this we can construct a complete match

- we don't need any more sinusoids to cover the rest of the quadrants, since the next two sinusoids (apart by π/2) would just be the negatives of our sin/cos probes


TODO: draw what it would look like with 4 sinusoids π/2 apart

<br><code> sin(π) = -sin(0) &  cos(3π/4) = -cos(0)</code>

<p> from the ratio of our sine and cosine matches we can figure out the actual phase and magnitude (as if we were using a sinusoid of that phase).
<p> magnitude is just the length of the diagonal line, which is equal to sqrt(sin<sup>2</sup> + cos<sup>2</sup>) </p>
<br><b>TODO</b> draw phase angle
</p>



<div id="example-3" class="example-plot">
  <div id="example-3-signal-plot"></div>
  <div id="example-3-xy-plot-"></div>
</div>

<input id="example-3-freq"  type="range" value=0 min=0 max=10 step=1>
<br>
<span id="example-3-result"></span>

<script>(() => {
  const targetSignal = sinusoid(4, Math.PI/4)
  const freqInput = document.getElementById('example-3-freq')
  const resultLabel = document.getElementById('example-3-result')

  const plot = createSignalPlot({domain: [0, 1], step: 0.01})
  document.querySelector('#example-3-signal-plot').appendChild(plot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-3-signal-plot').appendChild(circle.svg.node())

  const drawExample = () => {
    const frequency = Number(freqInput.value)
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    plot.update({
      targetSignal,
      sine,
      cosine,
      sineTransform,
      cosineTransform,
    })

    const [sineResult, cosineResult] = plot.result()

    circle.update(cosineResult, sineResult)
    resultLabel.innerText = `f=${frequency}Hz,  transform=(${sineResult.toFixed(2)}, ${cosineResult.toFixed(2)})`
  }
  d3.select(freqInput).on('change', drawExample)
  drawExample()


})()</script>


<h2>Fourier analysis</h2>


<pre>
  Complex signal
  - frequency graph with bins shows magnitudes for all probed frequencies

  - TODO: draw clickable empty recs with vertical dashed lines...
     draw magnitudes as smaller recs in-between
</pre>


<div id="example-4" class="example-plot">
  <!-- interactive demo -->
</div>
<select id="example-4-step">
  <option value="1">1Hz</option>
  <option value="0.5">0.5Hz</option>
  <option value="0.25">0.25Hz</option>
</select>


<script>(() => {
  let frequency = 0
  const domain = [0, 1]
  const step = 0.01

  const onBinSelected = (i) => {
    frequency = i
    drawExample()
  }
  const plot = createSignalPlot({domain, step})
  document.querySelector('#example-4').appendChild(plot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-4').appendChild(circle.svg.node())

  const stepInput = document.querySelector('#example-4-step')

  const components = [
    sinusoid(2),
    sinusoid(4, Math.PI, 0.5),
    sinusoid(7, Math.PI/4, 0.3)
  ]
  const targetSignal = combine(...components)

  const analysis = (frequency) => {
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI / 2)
    // naive DFT
    const complex = [0, 0]
    for (const t of d3.range(domain[0], domain[1]+step, step)) {
      complex[0] += targetSignal(t) * cosine(t),
      complex[1] -= targetSignal(t) * sine(t)
    }
    return magnitude(complex)
  }

  const freqPlot = createFreqPlot({domain: [0, 10], onBinSelected})
  document.querySelector('#example-4').appendChild(freqPlot.svg.node())


  const drawExample = () => {
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)
    const step = Number(stepInput.value)

    plot.update({
      targetSignal,
      sine,
      cosine,
      sineTransform,
      cosineTransform,
    })

    freqPlot.update(analysis, step)

    const [sineResult, cosineResult] = plot.result()

    circle.update(cosineResult, sineResult)
  }

  d3.select(stepInput).on('change', drawExample)

  drawExample()

})()</script>


<hr />


<h3>Spectral leakage </h3>
<p> what happens if we analyze in-between frequencies</p>

<p> what happens if we use are discrete frequency probes to detect a frequency that's in-between?</p>
<p> same plots but there is one frequency that's 4.5 Hz or something</p>

<p> We can see that for non-integer frequencies we get spill over into adjacent buckets, the
by interpolating we can recognize that the actual peak is somewhere between 4Hz & 5Hz</p>

<div id="example-5" class="example-plot">
  <!-- interactive demo -->
</div>

<select id="example-5-step">
  <option value="1">1Hz</option>
  <option value="0.5">0.5Hz</option>
  <option value="0.25">0.25Hz</option>
</select>


<script>(() => {
  let frequency = 0
  const onBinSelected = (i) => {
    frequency = i
    drawExample()
  }
  const domain = [0, 1]
  const step = 0.01

  const plot = createSignalPlot({domain, step})
  document.querySelector('#example-5').appendChild(plot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-5').appendChild(circle.svg.node())

  const stepInput = document.querySelector('#example-5-step')

  const targetSignal = sinusoid(4.5, Math.PI / 3)

  const analysis = (f) => {
    const sine = sinusoid(f)
    const cosine = sinusoid(f, Math.PI / 2)
    // naive DFT
    const complex = [0, 0]
    for (const t of d3.range(domain[0], domain[1]+step, step)) {
      complex[0] += targetSignal(t) * cosine(t),
      complex[1] -= targetSignal(t) * sine(t)
    }
    return magnitude(complex)
  }

  const freqPlot = createFreqPlot({domain: [0, 10], step: 1, onBinSelected})
  document.querySelector('#example-5').appendChild(freqPlot.svg.node())

  const drawExample = () => {
    const step = Number(stepInput.value)
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    plot.update({
      targetSignal,
      sine,
      cosine,
      sineTransform,
      cosineTransform,
    })

    freqPlot.update(analysis, step)

    const [sineResult, cosineResult] = plot.result()

    circle.update(cosineResult, sineResult)
  }
  d3.select(stepInput).on('change', drawExample)

  drawExample()

})()</script>




<h3>Sinc function </h3>

<p> <b>2.5Hz</b></p>

<div id="example-6" class="example-plot">
  <!-- interactive demo -->
</div>

<b> TODO: toggle to pick betwee 2Hz and 2.5 Hz, notice the difference between leakage and no leakage

<script>(() => {

  const signal = sinusoid(2.5)
  const domain = [0, 1]
  const step = 0.05

  const plot = createLinePlot({
    domain: domain,
    step: step,
    func: signal
  })
  document.querySelector('#example-6').appendChild(plot.svg.node())


  const analysis = (frequency) => {
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI / 2)
    // naive DFT
    const complex = [0, 0]
    for (const t of d3.range(domain[0], domain[1]+step, step)) {
      complex[0] += signal(t) * cosine(t),
      complex[1] -= signal(t) * sine(t)
    }
    return magnitude(complex)
  }


  const freqPlot = createAreaPlot({
    domain: [0, 20],
    step: 0.01,
    func: analysis
  })
  document.querySelector('#example-6').appendChild(freqPlot.svg.node())


})()</script>


<h3>Complex numbers </h3>

<br>
Just a convenient math way to write sin/cos


</body>
</html>
