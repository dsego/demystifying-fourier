<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Interactive DFT</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
</head>

<body>

<h1>DFT</h1>

<p>
<pre>

  * sound - repeating patterns in pressure. oscillations propagated in a medium -> waveform
    - beats - interference pattern between two frequencies

  * decompose complex waveform into sinusoids
    - we can reconstruct any waveform from other periodic waves (summation of sine signals)
    - sinusoids are a good choice because they have nice mathematical properties (they also represent up-and-down motion of pistons on a crankshaft)
    - cannot correctly reproduce discontinuous signals (but good enough when band limited?)
    - sines have no special connection to real-word phenomena -> sound waves are not made out of sines as a real-world phenomena!


  * Fourier formula
  * DFT formula
</pre>
</p>



<h2>Probing</h2>

<div id="example-1" style="width:950px; margin-left: -100px">
  <!-- interactive demo -->
</div>

200Hz <input type="range" value=0 /><br>
300Hz <input type="range" value=0 /><br>
300Hz (phase shifted) <input type="range" value=0 />

<script>(() => {
  const createPlot = (size) => {
    const width = 600
    const height = 200
    const domain = [0, size]

    const svg = d3.create('svg')
    svg.attr('viewBox', [0, 0, width, height])

    const margin = {top: 20, right: 30, bottom: 30, left: 40}
    const x = d3.scaleLinear()
      .domain(domain)
      .range([margin.left, width - margin.right])

    const y = d3.scaleLinear()
      .domain([-3, 3])
      .range([height - margin.bottom, margin.top])

    // Axes
    svg.append('g')
      .attr('transform', `translate(0,${y(0)})`)
      .call(d3.axisBottom(x).ticks())
      .call(g => g.select('.tick:first-of-type text').text(''))

    svg.append('g')
      .attr('transform', `translate(${margin.left},0)`)
      .call(d3.axisLeft(y).ticks(5))

    return {svg, x, y}
  }

  const seconds = 1

  const sinusoid = (frequency, phase=0, amplitude=1) => (
    (time) => amplitude * Math.sin(2 * Math.PI * frequency * time + phase)
  )

  const combine = (...sinusoids) => (
    (time) => sinusoids.reduce((res, s) => res + s(time), 0)
  )




  const plot = createPlot(seconds)
  document.querySelector('#example-1').appendChild(plot.svg.node())

  const waveform = combine(sinusoid(2), sinusoid(4), sinusoid(7, Math.PI))
  const line = d3.line()
    .curve(d3.curveNatural)
    .x(plot.x)
    .y((t) => plot.y(waveform(t)))


  const waveformPath = plot.svg.append('path')
    .attr('fill', 'none')
    .attr('stroke', 'deeppink')
  waveformPath.attr('d', line(d3.range(0, seconds+0.01, 0.01)))

})()</script>





  <pre>
    1. probing with sinewave by changing freq (dragging ?), fixed phase
    2. probing with sinewave by dragging on the chart left right / fixed frequency
    3. probing with sine & sine + π/2 (cosine)
    4. chart with sine, sine + π/2, sine+π, sine+3π/2  (sine, cosine, negative sine, negative cosine)
    5. chart with sine/cosine & unit circle, draging sine/cosine moves the line on the circle
  </pre>




  <p>probing with a single sinewave - fixed phase (Fourier sine transform )</p>

  <p> https://en.wikipedia.org/wiki/Sine_and_cosine_transforms </p>

  <pre>
  freq 0 - 3
  samples  0 - 7

  A &times; sin(2&pi;ft + &phi;)



   1) Probing example

    sine probe misses: phase  π / 2, 3/2, 5/2,  freq 3
    cosine probe misses:  phase 0, π, 2π, 3π, freq 3
    freq 3.4, phase 0 --> frequency bin spillover

    selected frequency is highlighted
      --> need a way to highlight select frequency bucket without bar
      maybe an arrow pointing at the axis band + bouncy animation  ?
    --> click area for each band? + dotted lines?


    ---> sinc function in freq domain


  </pre>

  <p>moving the phase by 45&deg;
  <p>probing with a sin & cos</p>
  <p>example of DFT</p>

  <div id="probing-example-2" style="width:950px; margin-left: -100px">

  </div>


  <fieldset>
    <legend>Probe</legend>
    Frequency
    <input type="number" value="0" id="frequency-input" min="0" max="7" step="1">
  </fieldset>



  <script>

    // setup
    const createChart = (size) => {
      const height = 200
      const width = 600

      const svg = d3.create("svg")
      svg.attr("viewBox", [0, 0, width, height])

      const margin = {top: 20, right: 30, bottom: 30, left: 40}
      const x = d3.scaleLinear()
        .domain([0, size])
        .range([margin.left, width - margin.right])

      const y = d3.scaleLinear()
        .domain([-2, 2])
        .range([height - margin.bottom, margin.top])

      // correlation
      const area1 = svg.append("path")
        .attr("fill", "lightsteelblue")
        .attr("fill-opacity", 0.2)

      const area2 = svg.append("path")
        .attr("fill", "lightsteelblue")
        .attr("fill-opacity", 0.2)

      // target signal
      const target = svg.append("path")
        .attr("fill", "none")
        .attr("stroke", "black")
        .attr("stroke-dasharray", "2,2")
        // .attr("stroke-width", 1.5)

      // sine probe
      const sineProbe = svg.append("path")
        .attr("fill", "none")
        .attr("stroke", 'deeppink')
        // .attr("stroke-opacity", 0.6)

      // cosine probe
      const cosineProbe = svg.append("path")
        .attr("fill", "none")
        .attr("stroke", "deepskyblue")
        // .attr("stroke-opacity", 0.6)

      const discrete = svg.append("g")
        .attr("fill", 'black')

      const discreteSine = svg.append("g")
        .attr("fill", 'deeppink')

      const discreteCosine = svg.append("g")
        .attr("fill", 'deepskyblue')

      // Axes
      svg.append("g")
        .attr("transform", `translate(0,${y(0)})`)
        .call(d3.axisBottom(x).ticks(size))
        .call(g => g.select(".tick:first-of-type text").text(""))

      svg.append("g")
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      return {
        svg,
        draw: (targetSignal, sineProbeSignal, cosineProbeSignal) => {
          const correlation = (t) => (0
            // targetSignal(t) * sineProbeSignal(t)
            // targetSignal(t) * cosineProbeSignal(t)
            // Math.abs(targetSignal(t) * cosineProbeSignal(t)) //- 0.5*cosineProbeSignal(t)
          )
          const targetPath = d3.line().curve(d3.curveNatural).x(x).y((t) => y(targetSignal(t)))
          const sineProbePath = d3.line().curve(d3.curveNatural).x(x).y((t) => y(sineProbeSignal(t)))
          const cosineProbePath = d3.line().curve(d3.curveNatural).x(x).y((t) => y(cosineProbeSignal(t)))
          const areaPath1 = d3.area().x(x).y0(y(0)).y1((t) => y(targetSignal(t) * sineProbeSignal(t)))
          const areaPath2 = d3.area().x(x).y0(y(0)).y1((t) => y(targetSignal(t) * cosineProbeSignal(t)))

          area1.attr("d", areaPath1(d3.range(0, size+0.1, 0.05)))
          area2.attr("d", areaPath2(d3.range(0, size+0.1, 0.05)))
          target.attr("d", targetPath(d3.range(0, size+0.1, 0.1)))
          sineProbe.attr("d", sineProbePath(d3.range(0, size+0.1, 0.1)))
          cosineProbe.attr("d", cosineProbePath(d3.range(0, size+0.1, 0.1)))

          discrete.selectAll("path")
            .data(d3.range(0, size))
            .join("line")
              .attr("stroke", "black")
              // .attr("stroke-width", 1)
              // .attr("stroke-opacity", 0.8)
              .attr("x1", i => x(i))
              .attr("x2", i => x(i))
              .attr("y1", i => y(targetSignal(i)))
              .attr("y2", i => y(0))

          discrete.selectAll("circle")
            .data(d3.range(0, size))
            .join("circle")
              .attr("cx", i => x(i))
              .attr("cy", i => y(targetSignal(i)))
              .attr("r", 3)

          discreteSine.selectAll("circle")
            .data(d3.range(0, size))
            .join("circle")
              .attr("cx", i => x(i))
              .attr("cy", i => y(sineProbeSignal(i)))
              .attr("r", 3)

          discreteCosine.selectAll("circle")
            .data(d3.range(0, size))
            .join("circle")
              .attr("cx", i => x(i))
              .attr("cy", i => y(cosineProbeSignal(i)))
              .attr("r", 3)
        }
      }
    }

    // frequency chart
    // bars are semi-transparent
    // selected frequency is highlighted

    const createFreqGraph = (size, onBarSelected, analysis) => {
      const height = 200
      const width = 600
      // const step = 1
      const step = 0.1 //  sinc function? :D

      const svg = d3.create("svg")
      svg.attr("viewBox", [0, 0, width, height])

      const margin = {top: 20, right: 30, bottom: 30, left: 40}
      const band = d3.scaleBand()
        .domain(d3.range(0, size, step))
        .range([margin.left, width - margin.right])
        .padding(0.2)

      // const point = d3.scaleBand()
      //   .domain(d3.range(0, size))
      //   .range([margin.left, width - margin.right])

      const y = d3.scaleLinear()
        .domain([0, 15])
        .range([height - margin.bottom, margin.top])

      // const discrete = svg.append("g")
      //   .attr("fill", 'black')

      const bars = svg.append("g")
        .attr("fill", "lightsteelblue")
        // .attr("fill-opacity", 0.5)

      // Axes
      svg.append("g")
        .attr("transform", `translate(0,${y(0)})`)
        .call(d3.axisBottom(band).tickValues(d3.range(0, 16)))

      svg.append("g")
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      return {
        svg,
        draw: (signal) => {
          bars.selectAll("rect")
            .data(d3.range(0, size, step))
            .join("rect")
              .attr("x", i => band(i))
              .attr("y", i => y(analysis(i, signal)))
              .attr("height", i => y(0) - y(analysis(i, signal)))
              .attr("width", band.bandwidth())
              .on("click", (event, i) => {
                bars.selectAll("rect").attr("fill", null)
                d3.select(event.target).attr("fill", "steelblue")
                onBarSelected(i)
              })
          // discrete.selectAll("path")
          //   .data(d3.range(0, size))
          //   .join("line")
          //     .attr("stroke", "black")
          //     // .attr("stroke-width", 1)
          //     // .attr("stroke-opacity", 0.8)
          //     .attr("x1", i => band(i) + band.bandwidth()/2)
          //     .attr("x2", i => band(i) + band.bandwidth()/2)
          //     .attr("y1", i => y(analysis(i, signal)))
          //     .attr("y2", i => y(0))

          // discrete.selectAll("circle")
          //   .data(d3.range(0, size))
          //   .join("circle")
          //     .attr("cx", i => band(i) + band.bandwidth()/2)
          //     .attr("cy", i => y(analysis(i, signal)))
          //     .attr("r", 3)
        }
      }
    }



    // const phase = Math.PI / 2
    const phase = 0
    const size = 16

    // const targetFreq = 3.4
    const targetFreq = 3.45
    const probeFreq = 0
    const amplitude = 1.8

    const targetSignal = (n) => {
      // produces sinc function? (because of d3 curveNatural)
      // if (parseInt(n) !== n) {
      //   console.log(n, parseInt(n))
      //   return 0
      // }
      return hann(n, size) * amplitude * Math.sin(2 * Math.PI * targetFreq * n/size + phase)
    }
    const sineProbe = (freq) => (n) => Math.sin(2 * Math.PI * freq * n/size)
    const cosineProbe = (freq) => (n) => Math.sin(2 * Math.PI * freq * n/size + Math.PI/2)
    // const cosineProbe = (freq) => (n) => 0

    // Naive DFT for a single analysis sinusoid
    const analysis = (sineProbe, cosineProbe) => (
      (analysisFreq, signal) => {
        const cosine = cosineProbe(analysisFreq)
        const sine = sineProbe(analysisFreq)
        const complex = d3.range(0, size).reduce((acc, i) => (
          [
            acc[0] + signal(i) * cosine(i),
            acc[1] - signal(i) * sine(i)
          ]
        ), [0, 0])
        return magnitude(complex)
      }
    )

    const magnitude = ([a, b]) => Math.sqrt(a*a + b*b)


    const hann = () => 1
    // const hann = (n, size) => 0.5 * (1 - Math.cos(2 * Math.PI * n / (size - 1)))



    const chart1 = createChart(size)
    document.querySelector("#probing-example-2").appendChild(chart1.svg.node())


    const onBarSelected = (i) => redraw(i)
    const freqGraph = createFreqGraph(size, onBarSelected, analysis(sineProbe, cosineProbe))
    document.querySelector("#probing-example-2").appendChild(freqGraph.svg.node())

    const redraw = (probeFreq) => {
      // chart1.draw(targetSignal, sineProbe(probeFreq), () => 0)
      chart1.draw(targetSignal, sineProbe(probeFreq), cosineProbe(probeFreq))
      freqGraph.draw(targetSignal)
    }

    redraw(probeFreq)


    document.querySelector("#frequency-input")
      .addEventListener("change", (e) => redraw(e.target.value))





  </script>
</body>
</html>
