<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Intuitive intro to sound analysis</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
  <style>
    .example-plot {
      width:800px;
      margin-left: -25px;
    }

    .example-plot svg {
      display: block;
      flex-grow: 1;
      flex-shrink: 0;
    }

    .range-slider {
      display: flex;
      gap: 10px;
      position: relative;
      align-items: center;
    }

    .range-slider input {
      margin-bottom: 0;
    }

    .range-slider output {
      display: inline-block;
      position: relative;
      min-width: 50px;
      line-height: 20px;
      text-align: center;
      border-radius: 3px;
      background: #CFD8DC;
      padding: 5px 10px;
      margin-left: 8px;
      margin-bottom: 0;
    }
    .range-slider output::after {
      position: absolute;
      top: 8px;
      left: -7px;
      width: 0;
      height: 0;
      border-top: 7px solid transparent;
      border-right: 7px solid #CFD8DC;
      border-bottom: 7px solid transparent;
      content: '';
    }
  </style>
  <script>
    const sinusoid = (frequency, phase = 0, amplitude = 1) => (
      (time) => amplitude * Math.sin(2 * Math.PI * frequency * time + phase)
    )

    const combine = (...sinusoids) => (
      (time) => sinusoids.reduce((res, s) => res + s(time), 0)
    )

    const magnitude = ([a, b]) => Math.sqrt(a * a + b * b)


    const createSVG = (width, height) => {
      const svg = d3.create('svg')
      svg
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height])
      return svg
    }

    const color = d3.scaleQuantize().domain([0, 5]).range(['#B0BEC5', '#FFE0B2'])

    const createSignalPlot = ({domain, step}) => {
      const width = 800
      const height = 300
      const svg = createSVG(width, height)

      const targetPath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 30)`)
        .attr('fill', 'none')
        .attr('stroke', '#29B6F6')
        .attr('stroke-width', 3)

      const sinePath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 90)`)
        .attr('fill', 'none')
        .attr('stroke', '#E91E63')
        .attr('stroke-width', 1.5)

      const cosinePath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 90)`)
        .attr('fill', 'none')
        .attr('stroke', '#E91E63')
        .attr('stroke-width', 1.5)

      const sineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 180)`)

      const cosineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 250)`)

      const range = d3.range(domain[0], domain[1]+step, step)
      const x = d3.scaleLinear().domain(domain).range([0, width])
      const y = d3.scaleLinear().domain([1, -1]).range([0, 50])
      const line = (func) => d3.line().curve(d3.curveNatural).x(x).y((t) => y(func(t)))
      const area = (func) => d3.area().curve(d3.curveNatural).x(x).y0(y(0)).y1((t) => y(func(t)))
      let result = [0, 0]

      return {
        svg,
        result: () => result,
        update: ({ targetSignal, sine, cosine, sineTransform, cosineTransform }) => {
          result = [
            d3.fsum(range, (t) => sineTransform(t)),
            cosineTransform ? d3.fsum(range, (t) => cosineTransform(t)) : undefined,
          ]
          targetPath.attr('d', line(targetSignal)(range))
          sinePath.attr('d', line(sine)(range))
          if (cosine) {
            cosinePath.attr('d', line(cosine)(range))
          }
          sineTransformPath
            .attr('d', area(sineTransform)(range))
            .attr('fill', color(Math.abs(result[0])))
          if (cosineTransform) {
            cosineTransformPath
              .attr('d', area(cosineTransform)(range))
              .attr('fill', color(Math.abs(result[1])))
          }
        }
      }
    }

    const createUnitCircle = () => {
      const width = 300
      const height = 300
      const svg = createSVG(width, height)
      const x = d3.scaleLinear().domain([-70, 70]).range([0, width])
      const y = d3.scaleLinear().domain([70, -70]).range([0, height])

      svg.append('ellipse')
        .attr('cx', x(0))
        .attr('cy', y(0))
        .attr('rx', x(50) - x(0))
        .attr('ry', y(0) - y(50))
        .attr('fill', 'none')
        .attr('stroke', '#B0BEC5')
        .attr('stroke-dasharray', '3 2')

      svg.append('g')
        .attr('transform', 'translate(' + [0, y(0)] + ')')
        .call(d3.axisBottom(x).ticks(2))
      svg.append('text')
        .text('cos')
        .attr('x', 270)
        .attr('y', 170)

      svg.append('g')
        .attr('transform', 'translate(' + [x(0), 0] + ')')
        .call(d3.axisLeft(y).ticks(2))
      svg.append('text')
        .text('sin')
        .attr('x', 270)
        .attr('y', 170)
        .style('transform-origin', 'center')
        .style('transform', 'rotate(-90deg)')

      const cosBar = svg.append('line')
        .attr('x1', x(0))
        .attr('y1', y(0))
        .attr('y2', y(0))
        .attr('stroke-width', 2)
        .attr('stroke', '#EC407A')

      const sinBar = svg.append('line')
        .attr('stroke-width', 2)
        .attr('stroke', '#EC407A')
        .attr('x1', x(0))
        .attr('y1', y(0))
        .attr('x2', x(0))

      const distance = svg.append('line')
        .attr('stroke-width', 2)
        .attr('stroke', '#EC407A')
        .attr('x1', x(0))
        .attr('y1', y(0))

      const arcPath = svg.insert('path')
        .style('transform', 'translate(150px, 150px)')
        .attr('fill', '#EC407A')
        .attr('stroke', 'none')
        .attr('fill-opacity', 0.2)

      const arc = d3.arc()
        .innerRadius(0)

      const update = (cos, sin) => {
        cosBar.attr('x2', x(cos))
        sinBar.attr('y2', y(sin))
        distance.attr('x2', x(cos)).attr('y2', y(sin))

        const dx = Math.abs(x(cos) - x(0))
        const dy = Math.abs(y(sin) - y(0))

        arc
          .startAngle(Math.PI/2)
          .endAngle(Math.PI/2 - Math.atan2(sin, cos))
          .outerRadius(Math.min(40, 0.8 * Math.sqrt(dx*dx + dy*dy)))
        arcPath.attr('d', arc())
      }

      return {
        svg,
        update
      }
    }

    const createFreqPlot = ({ domain, onBinSelected }) => {
      const height = 200
      const width = 800
      const svg = createSVG(width, height)
      const margin = { top: 20, right: 30, bottom: 30, left: 40 }

      const barBand = d3.scaleBand()
        .range([margin.left, width - margin.right])

      const binBand = d3.scaleBand()
        .range([margin.left, width - margin.right])

      const y = d3.scaleLinear()
        .domain([0, 55])
        .range([height - margin.bottom, margin.top])

      const bars = svg.append('g')

      const xAxis = svg.append('g').attr('transform', `translate(0,${y(0)})`)

      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      const binLines = svg.append('g')
      const bins = svg.append('g')
        .attr('fill', 'transparent')
        .attr('cursor', 'pointer')

      return {
        svg,
        update: (analysis, step, freq) => {
          const range = d3.range(domain[0], domain[1]+step, step)
          barBand.domain(range)
          binBand.domain(range)
          xAxis.call(d3.axisBottom(barBand).tickValues(barBand.domain().filter((d) => Number.isInteger(d))))

          bars.selectAll('rect')
            .data(range)
            .join('rect')
              .attr('fill', '#F8BBD0')
              .attr('x', d => barBand(d) + 0.2 * barBand.bandwidth())
              .attr('y', d => y(analysis(d)))
              .attr('height', d => y(0) - y(analysis(d)))
              .attr('width', 0.6 * barBand.bandwidth())

          binLines.selectAll('line')
            .data(range)
            .join('line')
              .attr('stroke', '#B0BEC5')
              .attr('stroke-dasharray', '3 2')
              .attr('x1', d => binBand(d) + binBand.bandwidth())
              .attr('y1', y(0))
              .attr('x2', d => binBand(d) + binBand.bandwidth())
              .attr('y2', y(55))

          bins.selectAll('rect')
            .data(range)
            .join('rect')
              .attr('stroke', d => d == freq ? '#EC407A' : 'transparent')
              .attr('stroke-width', 2)
              .attr('x', d => binBand(d))
              .attr('y', d => y(55))
              .attr('height', d => y(0) - y(55))
              .attr('width', binBand.bandwidth())
              .on('click', (event, d) => onBinSelected(d))
        }
      }
    }


    const createLinePlot = () => {
      const width = 800
      const height = 300
      const svg = createSVG(width, height)

      const margin = { top: 20, right: 30, bottom: 30, left: 40 }
      const x = d3.scaleLinear().range([margin.left, width - margin.right])
      const y = d3.scaleLinear().domain([1.5, -1.5]).range([margin.top, height - margin.bottom])

      const xAxis = svg.append('g')
        .attr('transform', `translate(0,${y(0)})`)

      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      const line = d3
        .line()
        .curve(d3.curveNatural)
        .x(x)

      const linePath = svg.insert('path', 'g')
        .attr('fill', 'none')
        .attr('stroke', '#29B6F6')
        .attr('stroke-width', 1.5)

      return {
        svg,
        update: ({domain, step, func}) => {
          const range = d3.range(domain[0], domain[1]+step, step)
          x.domain(domain)
          xAxis.call(d3.axisBottom(x).ticks(5))
          line.y((t) => y(func(t)))
          linePath.attr('d', line(range))
        }
      }
    }

    const createAreaPlot = () => {
      const width = 800
      const height = 300
      const svg = createSVG(width, height)

      const margin = { top: 20, right: 30, bottom: 30, left: 40 }

      const x = d3.scaleLinear().range([margin.left, width - margin.right])
      const y = d3.scaleLinear().range([height - margin.bottom, margin.top])

      const xAxis = svg.append('g')
        .attr('transform', `translate(0,${y(0)})`)

      const yAxis = svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)

      const area = d3
        .area()
        .curve(d3.curveNatural)
        .x(x)
        .y0(y(0))

      const areaPath = svg.insert('path', 'g')
        .attr('fill', '#7986CB')

      return {
        svg,
        update: ({domain, func, step}) => {
          const range = d3.range(domain[0], domain[1]+step, step)
          const result = range.map(t => func(t))
          const max = d3.max(result)

          x.domain(domain)
          xAxis.call(d3.axisBottom(x).ticks(15))

          y.domain([0, max])
          yAxis.call(d3.axisLeft(y).ticks(5))

          area.y1((t, i) => y(result[i]))
          areaPath.attr('d', area(range))
        }
      }
    }

  </script>
</head>

<body>

<h1>Intuitive intro to sound analysis</h1>

<p>
<pre>

  * sound - repeating patterns in pressure. oscillations propagated in a medium -> waveform
    - beats - interference pattern between two frequencies

  * decompose complex waveform into sinusoids
    - we can reconstruct any waveform from other periodic waves (summation of sine signals)
    - sinusoids are a good choice because they have nice mathematical properties (they also represent up-and-down motion of pistons on a crankshaft)
    - cannot correctly reproduce discontinuous signals (but good enough when band limited?)
    - sines have no special connection to real-word phenomena -> sound waves are not made out of sines as a real-world phenomena!


  * Fourier formula
  * DFT formula


  - mechanistic mind
</pre>
</p>



<h2>Probing with a single sinewave - fixed phase </h2>

<img src="https://i.imgflip.com/gkh5g.jpg" />

<p>probing with a single sinewave - fixed phase (Fourier sine transform )</p>
<p> https://en.wikipedia.org/wiki/Sine_and_cosine_transforms </p>

<p><pre> f(t) * sin(2πft) dt </pre></p>

<p>example 4Hz sinewave </p>

<p>
  the resulting transform is the area<br>
  troughs and peaks cancel out -> when you sum it together you get a high positive result when the probe highly correlates to the signal,
  for non-matching frequencies the result is practically zero (is it zero or tiny and negligible?)
  <br> also depends on amplitude of the signal we want to analyze

 </p>

 <p>TODO: add labels on the left side of example:  target function, sine probe function (reflects changing freq) and transform function</p>

<div id="example-1" class="example-plot">
  <!-- interactive demo -->
</div>

<div class="range-slider">
  <input id="example-1-control" type="range" value=0 min=0 max=10 step=1>
  <output id="example-1-freq"></output>
</div>

<output id="example-1-result"></output>

<script>(() => {
  const targetSignal = sinusoid(4)
  const plot = createSignalPlot({domain: [0, 1], step: 0.01})
  document.querySelector('#example-1').appendChild(plot.svg.node())

  const input = document.getElementById('example-1-control')
  const freqLabel = document.getElementById('example-1-freq')
  const resultLabel = document.getElementById('example-1-result')

  const drawExample = () => {
    const frequency = Number(input.value)
    const sine = sinusoid(frequency)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    plot.update({
      targetSignal,
      sine,
      sineTransform,
    })
    const [result, _] = plot.result()
    freqLabel.innerText = `${frequency}Hz`
    resultLabel.innerText = `sine transform=${result.toFixed(2)} (${result})`
  }
  d3.select(input).on('change', drawExample)
  drawExample()

})()</script>


<h3>Probing and phase</h3>

<p>The signal is still 4Hz but offset by a phase π/2 </p>
<p> Why can't we match the signal?</p>

<p> Let's try using a cosine transform to probe ... notice we're also getting some noise  (non-zero results for non-matching frequencies)
</p>

<div id="example-2" class="example-plot">
  <!-- interactive demo -->
</div>
<p>
  <label>Probe type</label>
  <select id="example-2-transform-type">
    <option value="sine">Sine</option>
    <option value="cosine">Cosine</option>
  </select>
</p>
<div class="range-slider">
  <input id="example-2-freq-input"  type="range" value=0 min=0 max=10 step=1>
  <output id="example-2-freq-label"></output>
</div>
<output id="example-2-result"></output>

<script>(() => {
  const targetSignal = sinusoid(4, Math.PI/2)

  const plot = createSignalPlot({domain: [0, 1], step: 0.01})
  document.querySelector('#example-2').appendChild(plot.svg.node())

  const typeInput = document.getElementById('example-2-transform-type')
  const freqInput = document.getElementById('example-2-freq-input')
  const freqLabel = document.getElementById('example-2-freq-label')
  const resultLabel = document.getElementById('example-2-result')

  const drawExample = () => {
    const frequency = Number(freqInput.value)
    const sine = typeInput.value === 'sine'
      ? sinusoid(frequency)
      : sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)

    plot.update({
      targetSignal,
      sine,
      sineTransform,
    })
    const [result, _] = plot.result()
    freqLabel.innerText = `${frequency}Hz`
    resultLabel.innerText = `${frequency}Hz, sine transform=${result.toFixed(2)} (${result})`
  }

  d3.selectAll([typeInput, freqInput]).on('change', drawExample)
  drawExample()
})()</script>

<br>
<br>

<h3>Probing with sin & cos = Fourier transform</h3>

<p> Let's try combining the sine & cosine transform in our analysis</p>

- we are now dealing with two numbers... you can notice both match partially, from this we can construct a complete match

- we don't need any more sinusoids to cover the rest of the quadrants, since the next two sinusoids (apart by π/2) would just be the negatives of our sin/cos probes


<br><code> sin(π) = -sin(0) &  cos(3π/4) = -cos(0)</code>

<p> from the ratio of our sine and cosine matches we can figure out the actual phase and magnitude (as if we were using a sinusoid of that phase).
<p> magnitude is just the length of the diagonal line, which is equal to sqrt(sin<sup>2</sup> + cos<sup>2</sup>) </p>

</p>



<div id="example-3" class="example-plot">
  <div id="example-3-signal-plot"></div>
  <div id="example-3-xy-plot-"></div>
</div>

<div class="range-slider">
  <input id="example-3-freq-input"  type="range" value=0 min=0 max=10 step=1>
  <output id="example-3-freq-label"></output>
</div>

<output id="example-3-result"></output>

<script>(() => {
  const targetSignal = sinusoid(4, Math.PI/4)
  const freqInput = document.getElementById('example-3-freq-input')
  const freqLabel = document.getElementById('example-3-freq-label')
  const resultLabel = document.getElementById('example-3-result')

  const plot = createSignalPlot({domain: [0, 1], step: 0.01})
  document.querySelector('#example-3-signal-plot').appendChild(plot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-3-signal-plot').appendChild(circle.svg.node())

  const drawExample = () => {
    const frequency = Number(freqInput.value)
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    plot.update({
      targetSignal,
      sine,
      cosine,
      sineTransform,
      cosineTransform,
    })

    const [sineResult, cosineResult] = plot.result()

    circle.update(cosineResult, sineResult)
    freqLabel.innerText = `${frequency}Hz`
    resultLabel.innerText = `
      transform=(${sineResult.toFixed(2)}, ${cosineResult.toFixed(2)})
      magnitude=${magnitude([sineResult, cosineResult]).toFixed(2)}
    `
  }
  d3.select(freqInput).on('change', drawExample)
  drawExample()


})()</script>

<h3>Sin/cos probes and their negatives</h3>

<div id="example-31" class="example-plot">
</div>
<script>(() => {

const height = 200
const width = 800
const domain = [0, 1]
const step = 0.01
const frequency = 1
const svg = createSVG(width, height)
const range = d3.range(domain[0], domain[1]+step, step)
const x = d3.scaleLinear().domain(domain).range([10, width-10])
const y = d3.scaleLinear().domain([1, -1]).range([10, height-10])

const line = (func) => d3.line().curve(d3.curveNatural).x(x).y((t) => y(func(t)))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#F06292')
  .attr('stroke-width', 2)
  .attr('d', line(sinusoid(frequency))(range))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#64B5F6')
  .attr('stroke-width', 2)
  .attr('d', line(sinusoid(frequency, Math.PI/2))(range))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#64B5F6')
  .attr('stroke-width', 2)
  .attr('stroke-dasharray', '2 2')
  .attr('d', line(sinusoid(frequency, 1.5*Math.PI))(range))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#F06292')
  .attr('stroke-width', 2)
  .attr('stroke-dasharray', '2 2')
  .attr('d', line(sinusoid(frequency, Math.PI))(range))


document.querySelector('#example-31').appendChild(svg.node())
})()</script>


<h2>Fourier analysis</h2>


<pre>
  Complex signal (2Hz + 4Hz + 7Hz)
  - frequency graph with bins shows magnitudes for all probed frequencies

</pre>


<div id="example-4" class="example-plot">
  <!-- interactive demo -->
</div>
<select id="example-4-step">
  <option value="1">1Hz</option>
  <option value="0.5">0.5Hz</option>
  <option value="0.25">0.25Hz</option>
</select>


<script>(() => {
  let frequency = 0
  const domain = [0, 1]
  const step = 0.01

  const onBinSelected = (i) => {
    frequency = i
    drawExample()
  }
  const plot = createSignalPlot({domain, step})
  document.querySelector('#example-4').appendChild(plot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-4').appendChild(circle.svg.node())

  const stepInput = document.querySelector('#example-4-step')

  const components = [
    sinusoid(2),
    sinusoid(4, Math.PI, 0.5),
    sinusoid(7, Math.PI/4, 0.3)
  ]
  const targetSignal = combine(...components)

  const analysis = (frequency) => {
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI / 2)
    // naive DFT
    const complex = [0, 0]
    for (const t of d3.range(domain[0], domain[1]+step, step)) {
      complex[0] += targetSignal(t) * cosine(t),
      complex[1] -= targetSignal(t) * sine(t)
    }
    return magnitude(complex)
  }

  const freqPlot = createFreqPlot({domain: [0, 10], onBinSelected})
  document.querySelector('#example-4').appendChild(freqPlot.svg.node())


  const drawExample = () => {
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)
    const step = Number(stepInput.value)

    plot.update({
      targetSignal,
      sine,
      cosine,
      sineTransform,
      cosineTransform,
    })

    freqPlot.update(analysis, step, frequency)

    const [sineResult, cosineResult] = plot.result()

    circle.update(cosineResult, sineResult)
  }

  d3.select(stepInput).on('change', drawExample)

  drawExample()

})()</script>


<hr />


<h3>Spectral leakage </h3>
<p> what happens if we analyze in-between frequencies</p>
<p> same plots but there is one frequency that's 4.5 Hz or something</p>
<p> We can see that for non-integer frequencies we get spill over into adjacent buckets, the
by interpolating we can recognize that the actual peak is somewhere between 4Hz & 5Hz</p>

<div id="example-5" class="example-plot">
  <!-- interactive demo -->
</div>

<select id="example-5-step">
  <option value="1">1Hz</option>
  <option value="0.5">0.5Hz</option>
  <option value="0.25">0.25Hz</option>
</select>


<script>(() => {
  let frequency = 0
  const onBinSelected = (i) => {
    frequency = i
    drawExample()
  }
  const domain = [0, 1]
  const step = 0.01

  const plot = createSignalPlot({domain, step})
  document.querySelector('#example-5').appendChild(plot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-5').appendChild(circle.svg.node())

  const stepInput = document.querySelector('#example-5-step')

  const targetSignal = sinusoid(4.5, Math.PI / 3)

  const analysis = (f) => {
    const sine = sinusoid(f)
    const cosine = sinusoid(f, Math.PI / 2)
    // naive DFT
    const complex = [0, 0]
    for (const t of d3.range(domain[0], domain[1]+step, step)) {
      complex[0] += targetSignal(t) * cosine(t),
      complex[1] -= targetSignal(t) * sine(t)
    }
    return magnitude(complex)
  }

  const freqPlot = createFreqPlot({domain: [0, 10], step: 1, onBinSelected})
  document.querySelector('#example-5').appendChild(freqPlot.svg.node())

  const drawExample = () => {
    const step = Number(stepInput.value)
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    plot.update({
      targetSignal,
      sine,
      cosine,
      sineTransform,
      cosineTransform,
    })

    freqPlot.update(analysis, step, frequency)

    const [sineResult, cosineResult] = plot.result()

    circle.update(cosineResult, sineResult)
  }
  d3.select(stepInput).on('change', drawExample)

  drawExample()

})()</script>




<h3>Sinc function </h3>

<p> <b>2.5Hz</b></p>

<div id="example-6" class="example-plot">
  <!-- interactive demo -->
</div>

<p>
leakage happens because our sine isn't infinite in time, an infinite sine would give perfect peaks in the spectrum plot.
but since we are analyzing with a fixed window of time, the sine signal is showing lobes in neighboring frequency bins.
with a finite window we will have many of our close or periodic probes give a weaker match because they or the signal
don't fit perfectly in the window and have some scrappy parts near each side of the window.

lobes happens because we the transforms don't cancel out when they should because they are cut off at the ends.
if we had an infinite window of time, all of these fake matches would cancel out and leave a pure spike for the probe that fully
matches our sinusoid.
<b> for perfect spectrum peak we need an infinite window!!!! </b>

mention "octopus" like shape of freq. spectrum

</p>

<label>Size (time)</label>
<select id="example-6-select">
  <option value="1">1s</option>
  <option value="5">5s</option>
  <option value="10">10s</option>
  <option value="30">30s</option>
</select>

<script>(() => {

  const signal = sinusoid(2.5)
  const step = 0.1

  const plot = createLinePlot()
  document.querySelector('#example-6').appendChild(plot.svg.node())

  const freqPlot = createAreaPlot()
  document.querySelector('#example-6').appendChild(freqPlot.svg.node())

  const sizeInput = document.getElementById('example-6-select')

  const drawExample = () => {
    const size = Number(sizeInput.value)
    const domain = [0, size]
    const range = d3.range(domain[0], domain[1]+step, step)

    const analysis = (frequency) => {
      const sine = sinusoid(frequency)
      const cosine = sinusoid(frequency, Math.PI / 2)
      // naive DFT
      const complex = [0, 0]
      for (const t of range) {
        complex[0] += signal(t) * cosine(t),
        complex[1] -= signal(t) * sine(t)
      }
      return magnitude(complex)
    }

    plot.update({domain, step, func: signal})
    freqPlot.update({domain: [0, 5], func: analysis, step: 0.01})
  }

  d3.select(sizeInput).on('change', drawExample)
  drawExample()

})()</script>


<h3>Complex numbers </h3>

<br>
Just a convenient math way to write sin/cos


sin cos pair need to be separated somehow, ergo multiply sin component by the imaginary number
real & imaginary don't mix.


<hr>
<pre>
TODO: add labels on the left side of example: target function, sine probe function (reflects changing freq) and transform function

</pre>

</body>
</html>
