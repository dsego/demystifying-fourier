<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Demystifying Fourier analysis</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    MathJax = {options:{skipHtmlTags:[]}}
  </script>
  <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.2/new.min.css">
  <style>

    h4 {
      position: relative;
      margin-bottom: .5rem;
    }

    h4 > :is(a:link, a:hover, a:active, a:visited) {
      display: block;
      color: unset;
      text-decoration: none;
    }

    h4::before {
      position: absolute;
      opacity: 0;
      left: -1rem;
      content: '§';
      font-weight: normal;
      transition: opacity 200ms ease;
    }

    h4:hover::before {
      opacity: 0.3;
    }

    .example-plot {
      width: 800px;
      margin-left: -25px;
    }

    .example-inset-70 {
      width: 850px;
      margin-left: -70px;
    }

    .example-inset-40 {
      width: 820px;
      margin-left: -40px;
    }

    .example-plot svg {
      display: block;
      flex-grow: 1;
      flex-shrink: 0;
    }

    .example-grid {
      display: grid;
      grid-template-columns: auto auto;
      grid-template-rows: auto auto;
    }
    .example-grid > :first-child {
      grid-column: span 2;
    }


    .range-slider {
      display: inline-flex;
      gap: 10px;
      position: relative;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .range-slider input, .range-slider select {
      margin-bottom: 0;
    }

    .range-slider output {
      display: inline-block;
      position: relative;
      min-width: 50px;
      line-height: 20px;
      text-align: center;
      border-radius: 4px;
      background: #F6F8FA;
      padding: 3px 6px;
      margin-left: 8px;
      margin-bottom: 0;
      border: 1px solid #E5E7EB;
      border-bottom: 3px solid #E5E7EB;
      font-size: 0.9rem;
    }
    .range-slider output::after {
      position: absolute;
      top: 8px;
      left: -7px;
      width: 0;
      height: 0;
      border-top: 7px solid transparent;
      border-right: 7px solid #E5E7EB;
      border-bottom: 7px solid transparent;
      content: '';
    }

    .signal-label {
      fill: #546E7A;
      font-size: 0.7rem;
      text-anchor: middle;
    }

    .circle-label {
      fill: #90A4AE;
      font-family: cursive;
      font-size: 0.9rem;
      text-anchor: middle;
    }

    .flex-row {
      display: flex;
      justify-content: space-around;
      align-items: center;
    }

    output {
      min-width: 50px;
      line-height: 20px;
      text-align: center;
      border-radius: 4px;
      background: #F6F8FA;
      padding: 5px 8px;
      border: 1px solid #E5E7EB;
      border-bottom: 3px solid #E5E7EB;
      font-size: 0.9rem;
      font-family: var(--nc-font-sans);
    }

  </style>
  <script>
    const sinusoid = (frequency, phase = 0, amplitude = 1) => (
      (time) => amplitude * Math.sin(2 * Math.PI * frequency * time + phase)
    )

    const combine = (...sinusoids) => (
      (time) => sinusoids.reduce((res, s) => res + s(time), 0)
    )

    const magnitude = ([a, b]) => Math.sqrt(a * a + b * b)

    // generate a single frequency analysis function (naive DFT)
    const analysis = (range, signal) => (freq) => {
      const sine = sinusoid(freq)
      const cosine = sinusoid(freq, Math.PI/2)
      const complex = [0, 0]
      for (const t of range) {
        complex[0] += signal(t) * cosine(t),
        complex[1] -= signal(t) * sine(t)
      }
      return magnitude(complex)
    }


    const createSVG = (width, height) => {
      const svg = d3.create('svg')
      svg
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height])
      return svg
    }

    const color = d3.scaleQuantize().domain([0, 5]).range(['#B0BEC5', '#FFE0B2'])

    const createSignalPlot = ({single, onPhaseChange} = {}) => {
      const width = 820
      const height = single ? 250 : 320
      const marginLeft = 70
      let result = [0, 0]
      let prevFreq = 0

      const svg = createSVG(width, height)

      const dragScale = d3.scaleLinear().domain([0, 1]).range([0, width-marginLeft])

      let dragPos = [0, 0]
      const drag = d3.drag()
        .on('drag', (e) => onPhaseChange(dragScale.invert(e.dx)))

      const g = svg.insert('g')
        .attr('transform', `translate(${marginLeft}, 30)`)

      if (onPhaseChange) g.call(drag)

      const targetPath = g.insert('path')
        .attr('fill', 'none')
        .attr('stroke', '#29B6F6')
        .attr('stroke-width', 2.5)

      if (onPhaseChange) {
        g.insert('rect')
          .attr('cursor', 'ew-resize')
          .attr('fill', 'transparent')
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', width)
          .attr('height', 60)
      }

      svg.append('text')
        .attr('class', 'signal-label')
        .text('target')
        .attr('x', 30)
        .attr('y', 60)

      const sinePath = svg.insert('g')
        .attr('transform', `translate(${marginLeft}, 90)`)
        .insert('path')
          .attr('fill', 'none')
          .attr('stroke', '#E91E63')
          .attr('stroke-width', 1.5)
          .attr('vector-effect', 'non-scaling-stroke')

      const cosinePath = svg.insert('g')
        .attr('transform', `translate(${marginLeft}, 90)`)
        .insert('path')
          .attr('fill', 'none')
          .attr('stroke', '#E91E63')
          .attr('stroke-width', 1.5)
          .attr('vector-effect', 'non-scaling-stroke')

      svg.append('text')
        .attr('class', 'signal-label')
        .text('probe')
        .attr('x', 30)
        .attr('y', 120)

      const sineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(${marginLeft}, 180)`)

      const cosineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(${marginLeft}, 250)`)

      const transformLabel = svg.append('text')
        .attr('class', 'signal-label')
        .text('transform')
        .attr('x', 30)
        .attr('y', 210)

      return {
        svg,
        update: ({targetData, frequency, sineData, cosineData, sineTransformData, cosineTransformData, result}) => {
          const x = d3.scaleLinear().domain([0, targetData.length]).range([0, width-marginLeft])
          const y = d3.scaleLinear().domain([1, -1]).range([0, 50])
          const line = d3.line().curve(d3.curveNatural).x((d, i) => x(i)).y((d) => y(d))
          const area = d3.area().curve(d3.curveNatural).x((d, i) => x(i)).y0(y(0)).y1((d) => y(d))

          targetPath
            .transition()
            .attr('d', line(targetData))

          sinePath.attr('visibility', sineData ? 'visible' : 'hidden')
          cosinePath.attr('visibility', cosineData ? 'visible' : 'hidden')
          transformLabel.attr('y', sineData && cosineData ? 240 : 210)

          // morph from flat line into sine/cosine
          if (frequency == 0 || prevFreq == 0 || prevFreq == frequency) {
            sinePath
              .transition()
              .attr('d', line(sineData ?? []))

            cosinePath
              .transition()
              .attr('d', line(cosineData ?? []))

          // pre-stretch the plot before transitioning to higher frequency
          } else if (frequency > prevFreq) {
            const scale = frequency / prevFreq
            sinePath
              .attr('d', line(sineData ?? []))
              .attr('transform', `scale(${scale} 1)`)
              .transition()
              .attr('transform', `scale(1 1)`)

            cosinePath
              .attr('d', line(cosineData ?? []))
              .attr('transform', `scale(${scale} 1)`)
              .transition()
              .attr('transform', `scale(1 1)`)

          // scale to lower frequency and then modify the path
          } else {
            const scale = prevFreq / frequency
            sinePath
              .transition()
              .attr('transform', `scale(${scale} 1)`)
              .on('end', () => {
                sinePath
                  .attr('transform', `scale(1 1)`)
                  .attr('d', line(sineData ?? []))
              })

            cosinePath
              .transition()
              .attr('transform', `scale(${scale} 1)`)
              .on('end', () => {
                cosinePath
                  .attr('transform', `scale(1 1)`)
                  .attr('d', line(cosineData ?? []))
              })
          }

          sineTransformPath
            .attr('visibility', sineTransformData ? 'visible' : 'hidden')
            .attr('fill', color(Math.abs(result[1])))
            .transition()
            .attr('d', area(sineTransformData ?? []))

          cosineTransformPath
            .attr('visibility', cosineTransformData ? 'visible' : 'hidden')
            .attr('fill', color(Math.abs(result[0])))
            .transition()
            .attr('d', area(cosineTransformData ?? []))

          if (cosineData && !sineData) {
            cosineTransformPath.attr('transform', `translate(${marginLeft}, 180)`)
          }

          prevFreq = frequency
        },
        updatePhase: ({targetData, sineTransformData, cosineTransformData, result}) => {
          const x = d3.scaleLinear().domain([0, targetData.length]).range([0, width-marginLeft])
          const y = d3.scaleLinear().domain([1, -1]).range([0, 50])
          const line = d3.line().curve(d3.curveNatural).x((d, i) => x(i)).y((d) => y(d))
          const area = d3.area().curve(d3.curveNatural).x((d, i) => x(i)).y0(y(0)).y1((d) => y(d))

          targetPath.attr('d', line(targetData))

          sineTransformPath
            .attr('fill', color(Math.abs(result[1])))
            .attr('d', area(sineTransformData ?? []))

          cosineTransformPath
            .attr('fill', color(Math.abs(result[0])))
            .attr('d', area(cosineTransformData ?? []))
        }
      }
    }

    const createPhaseDemoPlot = ({domain, onPhaseChange}) => {
      const width = 620
      const height = 320
      const marginLeft = 70

      const dragScale = d3.scaleLinear().domain(domain).range([0, width-marginLeft])
      const svg = createSVG(width, height)

      let dragPos = [0, 0]
      const drag = d3.drag()
        .on('drag', (e) => onPhaseChange(dragScale.invert(e.dx)))

      const g = svg.insert('g')
        .attr('transform', `translate(0, 30)`)
        .call(drag)

      g.insert('rect')
        .attr('cursor', 'ew-resize')
        .attr('fill', 'transparent')
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', width)
        .attr('height', 60)

      const targetPath = g.insert('path')
        .attr('fill', 'none')
        .attr('stroke', '#29B6F6')
        .attr('stroke-width', 2.5)

      svg.append('text')
        .attr('class', 'signal-label')
        .text('target')
        .attr('x', 30)
        .attr('y', 60)

      const sinePath = svg.insert('g')
        .attr('transform', `translate(0, 90)`)
        .insert('path')
          .attr('fill', 'none')
          .attr('stroke', '#E91E63')
          .attr('stroke-width', 1.5)
          .attr('vector-effect', 'non-scaling-stroke')

      const cosinePath = svg.insert('g')
        .attr('transform', `translate(0, 90)`)
        .insert('path')
          .attr('fill', 'none')
          .attr('stroke', '#E91E63')
          .attr('stroke-width', 1.5)
          .attr('vector-effect', 'non-scaling-stroke')

      svg.append('text')
        .attr('class', 'signal-label')
        .text('probe')
        .attr('x', 30)
        .attr('y', 120)

      const sineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 180)`)
        .attr('fill', '#FFE0B2')

      const cosineTransformPath = svg.insert('path', 'g')
        .attr('transform', `translate(0, 250)`)
        .attr('fill', '#FFE0B2')

      svg.append('text')
        .attr('class', 'signal-label')
        .text('sine')
        .attr('x', 30)
        .attr('y', 210)

      svg.append('text')
        .attr('class', 'signal-label')
        .text('cosine')
        .attr('x', 30)
        .attr('y', 280)

      return {
        svg,
        update: ({targetData, sineData, cosineData, sineTransformData, cosineTransformData, result}) => {
          const x = d3.scaleLinear().domain([0, targetData.length]).range([marginLeft, width])
          const y = d3.scaleLinear().domain([1, -1]).range([0, 50])

          const line = d3.line().curve(d3.curveNatural).x((d, i) => x(i)).y((d) => y(d))
          const area = d3.area().curve(d3.curveNatural).x((d, i) => x(i)).y0(y(0)).y1((d) => y(d))

          targetPath.attr('d', line(targetData))
          sinePath.attr('d', line(sineData))
          cosinePath.attr('d', line(cosineData))
          sineTransformPath
            .attr('d', area(sineTransformData))
            // .attr('fill', color(Math.abs(result[1])))
          cosineTransformPath
            .attr('d', area(cosineTransformData))
            // .attr('fill', color(Math.abs(result[0])))
        }
      }
    }

    const createUnitCircle = () => {
      const width = 180
      const height = 180
      const svg = createSVG(width, height)
      const x = d3.scaleLinear().domain([-65, 65]).range([0, width])
      const y = d3.scaleLinear().domain([65, -65]).range([0, height])

      svg.append('ellipse')
        .attr('cx', x(0))
        .attr('cy', y(0))
        .attr('rx', x(50) - x(0))
        .attr('ry', y(0) - y(50))
        .attr('fill', 'none')
        .attr('stroke', '#B0BEC5')
        .attr('stroke-dasharray', '3 2')

      svg.append('g')
        .attr('transform', `translate(${[0, y(0)]})`)
        .call(d3.axisBottom(x).ticks(2))

      svg.append('text')
        .text('cos')
        .attr('x', x(50))
        .attr('y', y(0))
        .attr('dx', 12)
        .attr('dy', -5)
        .attr('class', 'circle-label')

      svg.append('g')
        .attr('transform', `translate(${[x(0), 0]})`)
        .call(d3.axisLeft(y).ticks(2))
      svg.append('text')
        .text('sin')
        .attr('x', x(0))
        .attr('y', y(50))
        .attr('dy', -5)
        .attr('dx', 12)
        .attr('class', 'circle-label')

      const arcPath = svg.insert('path', 'g')
        .attr('transform', `translate(${[x(0), y(0)]})`)
        .attr('fill', '#FFF3E0')
        .attr('stroke', '#FFCC80')

      const cosBar = svg.append('line')
        .attr('stroke-width', 3)
        .attr('stroke-linecap', 'round')
        .attr('stroke', '#FF9800')
        .attr('x1', x(0))
        .attr('y1', y(0))
        .attr('y2', y(0))

      const sinBar = svg.append('line')
        .attr('stroke-width', 3)
        .attr('stroke-linecap', 'round')
        .attr('stroke', '#FF9800')
        .attr('x1', x(0))
        .attr('y1', y(0))
        .attr('x2', x(0))

      const distance = svg.append('line')
        .attr('stroke-width', 2)
        .attr('stroke-linecap', 'round')
        .attr('stroke', '#FF9800')
        .attr('x1', x(0))
        .attr('y1', y(0))
        .attr('x2', x(0))
        .attr('y2', y(0))

      const arc = d3.arc().innerRadius(0)

      const update = (cos, sin, enableTransitions) => {
        const alreadyDrawn = cosBar.attr('x2')

        if (enableTransitions && alreadyDrawn) {
          cosBar.transition().attr('x2', x(cos))
          sinBar.transition().attr('y2', y(sin))
          distance.transition().attr('x2', x(cos)).attr('y2', y(sin))
        } else {
          cosBar.attr('x2', x(cos))
          sinBar.attr('y2', y(sin))
          distance.attr('x2', x(cos)).attr('y2', y(sin))
        }

        const dx = Math.abs(x(cos) - x(0))
        const dy = Math.abs(y(sin) - y(0))

        arc
          .startAngle(Math.PI/2)
          .endAngle(Math.PI/2 - Math.atan2(sin, cos))
          .outerRadius(Math.min(40, 0.8 * Math.sqrt(dx*dx + dy*dy)))

        arcPath.attr('d', arc())

        if (enableTransitions && alreadyDrawn) {
          arcPath
            .attr('opacity', 0)
            .transition()
            .attr('opacity', 1)
        }
      }

      return {
        svg,
        update
      }
    }

    const createFreqBarPlot = ({domain, onBinSelected}) => {
      const height = 200
      const width = 670
      const svg = createSVG(width, height)
      const margin = { top: 20, right: 20, bottom: 30, left: 70 }

      const barBand = d3.scaleBand()
        .range([margin.left, width - margin.right])

      const binBand = d3.scaleBand()
        .range([margin.left, width - margin.right])

      const y = d3.scaleLinear()
        .domain([0, 55])
        .range([height - margin.bottom, margin.top])

      const bars = svg.append('g')

      const xAxis = svg.append('g').attr('transform', `translate(0,${y(0)})`)

      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      const binLines = svg.append('g')
      const bins = svg.append('g')
        .attr('fill', 'transparent')
        .attr('cursor', 'pointer')

      const selectedBin = svg.append('rect')
        .attr('fill', 'transparent')
        .attr('stroke-width', 2)
        .attr('stroke', '#FFA726')
        .attr('y', y(55))
        .attr('height', y(0) - y(55))
        .attr('rx', 3)

      return {
        svg,
        update: (analysis, step, freq) => {
          const range = d3.range(domain[0], domain[1]+step, step)
          const data = range.map(d => analysis(d))

          barBand.domain(range)
          binBand.domain(range)

          xAxis.call(d3.axisBottom(barBand).tickValues(barBand.domain().filter((d) => Number.isInteger(d))))

          bars.selectAll('rect')
            .data(data)
            .join('rect')
              .attr('fill', '#FFE0B2')
              .attr('x', (d,i) => barBand(range[i]) + 0.2 * barBand.bandwidth())
              .attr('y', d => y(d))
              .attr('height', d => y(0) - y(d))
              .attr('width', 0.6 * barBand.bandwidth())

          binLines.selectAll('line')
            .data(range)
            .join('line')
              .attr('stroke', '#B0BEC5')
              .attr('stroke-dasharray', '3 2')
              .attr('x1', d => binBand(d) + binBand.bandwidth())
              .attr('y1', y(0))
              .attr('x2', d => binBand(d) + binBand.bandwidth())
              .attr('y2', y(55))

          bins.selectAll('rect')
            .data(range)
            .join('rect')
              .attr('x', d => binBand(d))
              .attr('y', y(55))
              .attr('height', y(0) - y(55))
              .attr('width', binBand.bandwidth())
              .on('click', (event, d) => onBinSelected(d))

          const transition = selectedBin.attr('x')
            ? selectedBin.transition().duration(150)
            : selectedBin

          transition
            .attr('width', binBand.bandwidth())
            .attr('x', binBand(freq) ?? binBand(0))
        }
      }
    }

    const createLinePlot = ({step, domain}) => {
      const width = 800
      const height = 200
      const svg = createSVG(width, height)

      const margin = { top: 20, right: 30, bottom: 30, left: 40 }
      const range = d3.range(domain[0], domain[1]+step, step)

      const x = d3.scaleLinear()
        .range([margin.left, width - margin.right])
        .domain(domain)

      const y = d3.scaleLinear()
        .domain([1.5, -1.5])
        .range([margin.top, height - margin.bottom])

      svg.append('defs').append('clipPath')
        .attr('id', 'clip')
        .append('rect')
        .attr('x', margin.left)
        .attr('y', -10)
        .attr('width', width - margin.right - margin.left)
        .attr('height', height)

      const xAxis = svg.append('g')
        .attr('transform', `translate(0,${y(0)})`)

      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(5))

      const line = d3
        .line()
        .curve(d3.curveNatural)
        .x(x)

      const linePath = svg.insert('path', 'g')
        .datum(range)
        .attr('clip-path', 'url(#clip)')
        .attr('fill', 'none')
        .attr('stroke', '#29B6F6')
        .attr('stroke-width', 1.5)
        .attr('vector-effect', 'non-scaling-stroke')

      return {
        svg,
        update: ({func, domain}) => {
          line.y((d) => y(func(d)))
          const scaledX = d3.scaleLinear()
            .domain(domain)
            .range([margin.left, width-margin.right])
          line.x(scaledX)
          linePath.transition().attr('d', line)
          xAxis.transition().call(d3.axisBottom(scaledX))
        }
      }
    }

    const createAreaPlot = ({domain}) => {
      const width = 800
      const height = 200
      const svg = createSVG(width, height)

      const margin = { top: 20, right: 30, bottom: 30, left: 40 }
      const x = d3.scaleLinear().range([margin.left, width - margin.right]).domain(domain)
      const y = d3.scaleLinear().range([height - margin.bottom, margin.top])

      const step = 0.01
      const range = d3.range(domain[0], domain[1]+step, step)

      const xAxis = svg.append('g')
        .attr('transform', `translate(0,${y(0)})`)

      const yAxis = svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)

      const area = d3
        .area()
        .curve(d3.curveNatural)
        .x(x)
        .y0(y(0))

      const areaPath = svg.insert('path', 'g').attr('fill', '#7986CB')

      return {
        svg,
        update: ({func, step}) => {
          const result = range.map(func)
          const max = d3.max(result)

          xAxis.call(d3.axisBottom(x).ticks(15))

          y.domain([0, max])
          yAxis.transition().call(d3.axisLeft(y).ticks(5))

          area.y1((t, i) => y(result[i]))
          areaPath
            .transition()
            .attr('d', area(range))
        }
      }
    }

  </script>
</head>

<body>

<h1>Demystifying Fourier analysis</h1>


<h4 id="intro"><a href="#intro">Intro</a></h4>

<p>I've started learning about spectrum analysis a long time ago at university,
  but failed to gain a true insight in how it works under the hood.
  For me, it was just some magical math formulas I had to memorize and know about.
  I knew the theory but it didn't really <q>click</q>.
</p>
<p>
  A few years ago I wanted to do some audio programming and play around with analyzing sound. That's
  how I got interested into building an intuition on how the Fourier transform <q>actually</q> works.
</p>
<p>I made these interactive examples mostly to improve my own understanding and learn by doing.
  I am following a mechanistic approach and building from the ground up with simpler building blocks,
  rather than introducing the formula and saying <cite><q>this is what it means.</q></cite>
  Since I mainly do web programming for a living, this seems to be easier to wrap my mind around than some <i>abstract math</i>.
</p>
<p>
  My language and math are very simplified, and probably a bit imprecise or not completely correct.
  I am also not including explanations for everything (like trigonometry functions etc, because that's out of scope)
  and completely ignoring some details that I didn't think are relevant (like negative frequencies).
</p>
<p>Feel free to submit any corrections or feedback in the <a href="https://github.com/dsego/demystifying-fourier">github repo</a>.
</p>


<h4 id="sound"><a href="#sound">Sound</a></h4>

<p> Sound comprises of oscillations or repeating patterns in pressure that propagate in a medium.
  Sound waves typically have complex patterns repeating at different frequencies.
  We can typically reconstruct any complex wave form from other periodic waves.
</p>
<p>Sinusoidal waves are a good choice for this because they have nice mathematical properties.
That is, sound waves are not made out of sines as real-word phenomena. </p>

<p>To quote one reddit comment:</p>

<blockquote cite="https://www.reddit.com/r/askscience/comments/huxkb/comment/c1ynlgj/?utm_source=share&utm_medium=web2x&context=3">
  <q>The only things "perfect" about a sine wave are its mathematical conveniences,
    it has no special connection to real-world phenomena.
    You could model those phenomena with equal precision with other waveforms.</q>
    <cite>~RickRussellTX</cite>
</blockquote>

<p>Sine waves also represent up-and-down motion of pistons on a crankshaft:</p>
<blockquote cite="https://www.reddit.com/r/askscience/comments/huxkb/comment/c1yobfr/?utm_source=share&utm_medium=web2x&context=3">
  <q>I suspect that the obsession with sine waves comes from the fact that in
  our daily machine-driven lives we have an awful lot of machines that rotate around an axis,
  or are attached to crankshafts and what-have you.
  A piston on a crankshaft produces "pure" sinusoidal up-and-down motion when operating at constant angular velocity.</q>
  <cite>~RickRussellTX</cite>
</blockquote>

<p>Sinusoids in fact cannot correctly reproduce discontinuous signals, but they are good enough for band-limited signals.</p>



<h4 id="probing-with-a-single-sine-wave">
  <a href="#probing-with-a-single-sine-wave">
    <q>Probing</q> with a single sine wave
  </a>
</h4>

<p style="margin-top: 2rem; text-align: center;">
  <img src="https://i.imgflip.com/gkh5g.jpg" alt="Let the probing... Begin!"/>
</p>

<p>
  We start from a relatively straightforward approach of <q><i>probing</i></q> or analyzing the target signal by
  doing a <a href="https://en.wikipedia.org/wiki/Sine_and_cosine_transforms"><i>sine transform</i></a>
  as originally done by Fourier himself. I'm using the term <q>probe</q> here, I've read it somewhere else already and it feels appropriate,
  but these are usually called <q><cite>analyzing functions.</cite></q>
</p>
<p>The idea is to multiply the signal with a pure sine wave.
  The resulting transform is the area, which can tell us how closely the signal aligns with our test sine wave.
</p>

<p>Here is a simplified formula for this idea:
$$\mathit{transform} = \mathit{area}(\ \mathit{target\ signal} \times \mathit{probe}\ )$$</p>

<p>For completeness sake, let's also include the math formula for our
 sine transform that analyzes the presence of frequency <i>s</i> in the target signal:</p>

$$F_{s} = \int_{-\infty}^\infty f(t) \times \sin(2πst) dt$$

<p>\(sin(2πst)\) is our sine analysis function (aka <i>probe</i>) and \(f(t)\) is our target signal.


<figure id="example-1" class="example-plot example-inset-70"><!-- interactive demo --></figure>

<div class="range-slider">
  <label style="width:250px"><small>Probe frequency</small></label>
  <input id="example-1-control" type="range" value=0 min=0 max=8 step=1>
  <output id="example-1-freq"></output>
</div>

<div class="range-slider">
  <label style="width:250px"><small>Target signal amplitude</small></label>
  <input id="example-1-amplitude" type="range" value=1 min=0 max=2 step=0.2 />
  <output id="example-1-amplitude-label"></output>
</div>
<p>
  <output id="example-1-result"></output>
</p>

<script>(() => {
  const domain = [0, 1]
  const step = 0.01
  const range = d3.range(domain[0], domain[1]+step, step)

  const plot = createSignalPlot({single: true})
  document.querySelector('#example-1').appendChild(plot.svg.node())

  const inputFreq = document.getElementById('example-1-control')
  const inputAmp = document.getElementById('example-1-amplitude')
  const inputAmpLabel = document.getElementById('example-1-amplitude-label')
  const freqLabel = document.getElementById('example-1-freq')
  const resultLabel = document.getElementById('example-1-result')

  const drawExample = () => {
    const frequency = Number(inputFreq.value)
    const amplitude = Number(inputAmp.value)
    const targetSignal = sinusoid(4, 0, amplitude)
    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    const targetData = range.map((d) => targetSignal(d))
    const sineData = range.map((d) => sine(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const result = d3.fsum(sineTransformData)

    plot.update({
      frequency,
      targetData,
      sineData,
      sineTransformData,
      result: [0, result]
    })

    freqLabel.innerText = `${frequency}Hz`
    inputAmpLabel.innerText = amplitude
    resultLabel.innerText = `Magnitude = ${result.toFixed(2)}`
  }
  d3.selectAll([inputFreq, inputAmp]).on('input', drawExample)
  drawExample()

})()</script>

<p>
  Our target signal is a <b>4Hz sine wave</b>.
  We can multiply it by a single sine probe with a fixed phase. This means it won't slide left or right, just change its frequency.
</p>
<p> When we aggregate all the values in the transform together, we get a high positive result if the probe correlates with the signal.
  This number represents the magnitude of the transform.
  For non-matching frequencies the result is zero because all the peaks and troughs cancel out.
</p>
<p>This is all there is to it, the magic trick behind the transform.
  The total sum of a single sine wave averages out to zero, because there are positive and negative sides.
  But when we multiply it with a correlating signal, multiplying the negatives will turn them into positive numbers,
  effectively resulting in a non-zero sum of the transform.
</p>
<p>
  Notice how the resulting magnitude and also depends on amplitude of the signal we want to analyze.
</p>



<h4 id="probing-and-phase">
  <a href="#probing-and-phase">
    Probing and phase
  </a>
</h4>

<p>Let's try to analyze a signal that is still <b>4Hz</b> but offset by a quarter of a turn (phase is <b>π/2</b>).</p>
<p> Why can't we match the signal?</p>

<figure id="example-2" class="example-plot example-inset-70"><!-- interactive demo --></figure>

<div class="range-slider">
  <select id="example-2-transform-type">
    <option value="sine">Sine</option>
    <option value="cosine">Cosine</option>
  </select>
  <input id="example-2-freq-input"  type="range" value=0 min=0 max=8 step=1>
  <output id="example-2-freq-label"></output>
</div>
<p>
  <output id="example-2-result"></output>
</p>

<script>(() => {
  const domain = [0, 1]
  const step = 0.01
  const range = d3.range(domain[0], domain[1]+step, step)
  const targetSignal = sinusoid(4, Math.PI/2)

  const plot = createSignalPlot({domain: [0, 1], step: 0.01, single: true})
  document.querySelector('#example-2').appendChild(plot.svg.node())

  const typeInput = document.getElementById('example-2-transform-type')
  const freqInput = document.getElementById('example-2-freq-input')
  const freqLabel = document.getElementById('example-2-freq-label')
  const resultLabel = document.getElementById('example-2-result')

  const drawExample = () => {
    const frequency = Number(freqInput.value)

    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    const targetData = range.map((d) => targetSignal(d))
    const sineData = range.map((d) => sine(d))
    const cosineData = range.map((d) => cosine(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])
    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    if (typeInput.value === 'sine') {
      plot.update({
        frequency,
        targetData,
        sineData,
        sineTransformData,
        result,
      })
    } else {
      plot.update({
        frequency,
        targetData,
        cosineData,
        cosineTransformData,
        result,
      })
    }

    freqLabel.innerText = `${frequency}Hz`

    if (typeInput.value === 'sine') {
      resultLabel.innerText = `Magnitude = ${result[1].toFixed(2)}`
    } else {
      resultLabel.innerText = `Magnitude = ${result[0].toFixed(2)}`
    }
  }

  d3.selectAll([typeInput, freqInput]).on('input', drawExample)
  drawExample()
})()</script>



<p>The sine probe is out of phase with the target signal and won't correlate.
Sinusoidal waves are periodic and repeat from the beginning every one turn around the circle, 360° or 2π radians.
When the phase of our probe doesn't match the phase of the target wave, we won't get a match.
</p>

<p> Let's turn our probe into a <i>cosine</i> wave. This will bring it back by a quarter of a turn to match the signal perfectly.
<p>Notice how we're also getting a so-called <cite>DC offset</cite> of magnitude 1 for all the frequencies that we are analyzing.
The transform for our 0Hz probe is also a replica of the original wave! This is because the <i>cosine</i> function is 1 when the phase is 0.
The <i>sine</i> starts at 0, so we don't see the same effect.
</p>


<h4 id="probing-with-sine-and-cosine">
  <a href="#probing-with-sine-and-cosine">
    <q>Probing</q> with sine and cosine
  </a>
</h4>

<p> Let's try combining the sine & cosine transforms in our analysis of a
  4Hz wave ofset by π/4 (half way between a sine and a cosine).
  This is effectively the famous <a href="https://en.wikipedia.org/wiki/Fourier_transform"><q>Fourier transform</q></a>.
  <br>
  We are now dealing with two numbers, which we can show on an 2d <i>xy-plot</i>.
</p>
<p>
  When we pick the 4Hz analysis waves, we can notice how both match partially.
  From this we can re-construct a complete match.
  Any movement in phase of the target wave will reflect in the sine and cosine components of our transform.
</p>

<figure id="example-3-signal-plot" class="example-plot example-inset-70"><!-- interactive demo --></figure>

<div class="flex-row">
  <div>
    <div class="range-slider">
      <label><small>Probe frequency</small></label>
      <input id="example-3-freq-input"  type="range" value=0 min=0 max=8 step=1>
      <output id="example-3-freq-label"></output>
    </div>
  </div>
  <figure id="example-3-xy-plot"><!-- interactive demo --></figure>
</div>
<p>
  <output id="example-3-result"></output>
</p>


<script>(() => {
  const domain = [0, 1]
  const step = 0.01
  const targetSignal = sinusoid(4, Math.PI/4)
  const range = d3.range(domain[0], domain[1]+step, step)

  const freqInput = document.getElementById('example-3-freq-input')
  const freqLabel = document.getElementById('example-3-freq-label')
  const resultLabel = document.getElementById('example-3-result')

  const plot = createSignalPlot({domain: [0, 1], step: 0.01})
  document.querySelector('#example-3-signal-plot').appendChild(plot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-3-xy-plot').appendChild(circle.svg.node())

  const drawExample = () => {
    const frequency = Number(freqInput.value)

    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    const targetData = range.map((d) => targetSignal(d))
    const sineData = range.map((d) => sine(d))
    const cosineData = range.map((d) => cosine(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])
    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    plot.update({
      targetData,
      sineData,
      cosineData,
      sineTransformData,
      cosineTransformData,
      frequency,
      result,
    })

    circle.update(result[0], result[1])
    freqLabel.innerText = `${frequency}Hz`
    resultLabel.innerText = `Transform = [${result[1].toFixed(2)}, ${result[0].toFixed(2)}], magnitude = ${magnitude(result).toFixed(2)}`
  }
  d3.select(freqInput).on('input', drawExample)
  drawExample()
})()</script>


<p>From the ratio of our sine and cosine matches we can figure out the actual phase and magnitude (as if we were using a sinusoid of that phase).
<p>The magnitude becomes the length of the diagonal line, which is equal to \(\sqrt{{sin}^2 + {cos}^2}\).
  The phase can be found from the ratio or angle between the sine & cosine components, ie \(atan2({sin}, {cos})\).
</p>



<h4 id="sinecosine-probes-and-their-negatives">
  <a href="#sinecosine-probes-and-their-negatives">Sine/cosine probes and their negatives</a>
</h4>
<p>We don't need any more <i>probes</i> to cover the rest of the quadrants, since the next two
sinusoids (apart by π/2) would just be the negatives of our sine/cosine probes. </p>

<p>$$\sin(π) = {-\sin(0)}, \ \  \cos(-{π\over4}) = {-\cos(0)}$$</p>



<p>
  <figure id="example-sincos" class="example-plot">
  <!-- interactive demo -->
  </figure>
</p>
<script>(() => {

const height = 150
const width = 800
const domain = [0, 1]
const step = 0.01
const frequency = 1
const svg = createSVG(width, height)
const range = d3.range(domain[0], domain[1]+step, step)
const x = d3.scaleLinear().domain(domain).range([30, width-30])
const y = d3.scaleLinear().domain([1, -1]).range([10, height-10])

const line = (func) => d3.line().curve(d3.curveNatural).x(x).y((t) => y(func(t)))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#F06292')
  .attr('stroke-width', 2)
  .attr('d', line(sinusoid(frequency))(range))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#64B5F6')
  .attr('stroke-width', 2)
  .attr('d', line(sinusoid(frequency, Math.PI/2))(range))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#64B5F6')
  .attr('stroke-width', 2)
  .attr('stroke-dasharray', '2 2')
  .attr('d', line(sinusoid(frequency, 1.5*Math.PI))(range))

svg.insert('path', 'g')
  .attr('fill', 'none')
  .attr('stroke', '#F06292')
  .attr('stroke-width', 2)
  .attr('stroke-dasharray', '2 2')
  .attr('d', line(sinusoid(frequency, Math.PI))(range))


document.querySelector('#example-sincos').appendChild(svg.node())
})()</script>

<h4 id="phase">
  <a href="#phase">Phase</a>
</h4>

<p>To further drive the point home, let's look at another interactive example.</p>
<p>Here we make the frequencies of both the signal under test and our sine/cosine probes set at <b>4Hz</b>
  and just look at the phase of the signal.
<p><b>Drag</b> the target sine wave left and right. Notice that our sine & cosine probes give a match for any phase in-between.</p>

<figure id="example-31" class="example-plot example-inset-70 flex-row"><!-- interactive demo --></figure>

<script>(() => {
  const domain = [0, 1]
  const step = 0.01
  const frequency = 4
  let phase = Math.PI/4
  let targetSignal = sinusoid(frequency, phase)

  const onPhaseChange = (delta) => {
    phase -= delta * 8 * Math.PI
    targetSignal = sinusoid(frequency, phase)
    draw()
  }

  const range = d3.range(domain[0], domain[1]+0.01, 0.01)
  const plot = createPhaseDemoPlot({domain, onPhaseChange})
  document.querySelector('#example-31').appendChild(plot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-31').appendChild(circle.svg.node())

  const sine = sinusoid(frequency)
  const cosine = sinusoid(frequency, Math.PI/2)
  const sineData = range.map((d) => sine(d))
  const cosineData = range.map((d) => cosine(d))

  const draw = () => {
    const targetData = range.map((d) => targetSignal(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])

    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    plot.update({
      targetData,
      sineData,
      cosineData,
      sineTransformData,
      cosineTransformData,
      result
    })

    circle.update(result[0], result[1], false)
  }
  draw()

})()</script>



<h4 id="analyzing-a-complex-wave">
  <a href="#analyzing-a-complex-wave">Analyzing a complex wave</a>
</h4>

Let's analyze a more complex signal which consists of multiple components, a strong one at 2Hz and two weaker ones at 4Hz & 7Hz.
The 4Hz component has a phase of π/3 and the 7Hz a phase of π/4.
This example includes a frequency spectrum plot that shows a bar for each analysis probe. Clicking on a frequency bin will
show the corresponding analysis function and transform (just as selecting the probe frequency on a slider in previous examples).

<figure id="example-4" class="example-plot example-grid example-inset-70"><!-- interactive demo --></figure>

<label><small>Granularity</small></label>
<select id="example-4-step">
  <option value="1">1Hz</option>
  <option value="0.5">0.5Hz</option>
  <option value="0.25">0.25Hz</option>
</select>


<script>(() => {
  const domain = [0, 1]
  const step = 0.01
  const range = d3.range(domain[0], domain[1]+step, step)

  let frequency = 0
  let frequencies = [2, 4, 7]
  let phases = [Math.PI/3, Math.PI, Math.PI/4]
  let targetSignal = combine(
    sinusoid(2, phases[0]),
    sinusoid(4, phases[1], 0.5),
    sinusoid(7, phases[2], 0.25)
  )

  let sine, cosine, sineData, cosineData

  const buildProbe = (freq) => {
    sine = sinusoid(freq)
    cosine = sinusoid(freq, Math.PI/2)
    sineData = range.map((d) => sine(d))
    cosineData = range.map((d) => cosine(d))
  }

  const onBinSelected = (i) => {
    frequency = i
    buildProbe(i)
    drawExample()
  }

  const onPhaseChange = (delta) => {
    phases = phases.map((p, i) => p - delta * 2 * frequencies[i] * Math.PI)
    targetSignal = combine(
      sinusoid(frequencies[0], phases[0]),
      sinusoid(frequencies[1], phases[1], 0.5),
      sinusoid(frequencies[2], phases[2], 0.25)
    )
    updatePhase()
  }
  const plot = createSignalPlot({onPhaseChange})
  document.querySelector('#example-4').appendChild(plot.svg.node())

  const freqPlot = createFreqBarPlot({domain: [0, 8], onBinSelected})
  document.querySelector('#example-4').appendChild(freqPlot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-4').appendChild(circle.svg.node())

  const stepInput = document.querySelector('#example-4-step')


  const updatePhase = () => {
    const step = Number(stepInput.value)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)
    const targetData = range.map((d) => targetSignal(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])
    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    plot.updatePhase({
      targetData,
      sineTransformData,
      cosineTransformData,
      result,
    })

    freqPlot.update(analysis(range, targetSignal), step, frequency)
    circle.update(result[0], result[1])
  }

  const drawExample = () => {
    const step = Number(stepInput.value)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)
    const targetData = range.map((d) => targetSignal(d))

    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])
    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    plot.update({
      frequency,
      targetData,
      sineData,
      cosineData,
      sineTransformData,
      cosineTransformData,
      result,
    })

    freqPlot.update(analysis(range, targetSignal), step, frequency)
    circle.update(result[0], result[1], false)
  }

  d3.select(stepInput).on('input', drawExample)
  buildProbe(0)
  drawExample()

})()</script>

<hr/>
<ul>
  <li>The frequency graph with bins shows magnitudes for all probed frequencies.</li>
  <li>Again, notice that the 0Hz band for our cosine transform produces an average of the signal (which is zero in this case).</li>
  <li>When choosing 1/4 Hertz resolution there is something strange going on.
    We don't get a nice single bar for each of the frequencies.
    Instead, the spectrum spills over into neighboring buckets.
  </li>
  <li>
    At 0.25Hz resolution the 3.75Hz frequency bar appears stronger than the 4Hz bar,
    even though it's a 4Hz component (the actual component has a phase of π).
  </li>
  <li>Drag the target signal left or right to change its phase. Notice how this affects the bars in the spectrum plot.
</ul>
<p>Let's examine these anomalies in our next examples.</p>



<h4 id="spectral-spillover">
  <a href="#spectral-spillover">Spectral spillover</a>
</h4>

<p>
  What happens if we analyze frequencies that are not whole numbers, but somewhere in-between?
  Let's say this time we are analyzing a frequency of <b>3.5Hz</b> with phase <b>π/3</b>.</p>
<p>
  See how for non-integer frequencies we don't get a single bar, instead the spectrum is spilling over into adjacent buckets.
  The actual peak is somewhere between 3Hz & 4Hz. We can figure out the actual peak either by interpolating
  between the bins, or we can increase the number of bins by creating more granular probes for analyzing.
</p>
<p>
 What's even stranger is how the spill-over shape doesn't just taper out like a bell curve,
 instead it oscillates up and down, but dampens as it spreads out,
 creating shapes known as <cite>lobes</cite>.
</p>

<figure id="example-5" class="example-plot example-grid example-inset-70"><!-- interactive demo --></figure>

<label><small>Granularity</small></label>
<select id="example-5-step">
  <option value="1">1Hz</option>
  <option value="0.5">0.5Hz</option>
  <option value="0.25">0.25Hz</option>
</select>


<script>(() => {
  let frequency = 0

  const onBinSelected = (i) => {
    frequency = i
    drawExample()
  }
  const domain = [0, 1]
  const step = 0.01
  const range = d3.range(domain[0], domain[1]+step, step)

  const plot = createSignalPlot()
  document.querySelector('#example-5').appendChild(plot.svg.node())

  const freqPlot = createFreqBarPlot({domain: [0, 8], step: 1, onBinSelected})
  document.querySelector('#example-5').appendChild(freqPlot.svg.node())

  const circle = createUnitCircle()
  document.querySelector('#example-5').appendChild(circle.svg.node())

  const stepInput = document.querySelector('#example-5-step')

  const targetSignal = sinusoid(3.5, Math.PI / 3)

  const drawExample = () => {
    const step = Number(stepInput.value)

    const sine = sinusoid(frequency)
    const cosine = sinusoid(frequency, Math.PI/2)
    const sineTransform = (t) => targetSignal(t) * sine(t)
    const cosineTransform = (t) => targetSignal(t) * cosine(t)

    const targetData = range.map((d) => targetSignal(d))
    const sineData = range.map((d) => sine(d))
    const cosineData = range.map((d) => cosine(d))
    const sineTransformData = range.map((d, i) => sineData[i] * targetData[i])
    const cosineTransformData = range.map((d, i) => cosineData[i] * targetData[i])
    const result = [
      d3.fsum(cosineTransformData),
      d3.fsum(sineTransformData),
    ]

    plot.update({
      frequency,
      targetData,
      sineData,
      cosineData,
      sineTransformData,
      cosineTransformData,
      result,
    })
    freqPlot.update(analysis(range, targetSignal), step, frequency)
    circle.update(result[0], result[1])
  }
  d3.select(stepInput).on('input', drawExample)
  drawExample()

})()</script>


<h4 id="sinc-function-and-spectral-resolution">
  <a href="#sinc-function-and-spectral-resolution">The sinc function & spectral resolution</a>
</h4>

<p>
This <i>spilling over</i> happens because our sine isn't infinite in time and we are analyzing
frequencies that are not all periodic with the fixed time interval.
<p>
An infinite sine would give perfect peaks in the spectrum plot, but our sine signal is showing lobes in neighboring frequency bins.
With a finite window we will have many of our probes that are close in frequency give a perceptible match.
That's because they or the signal don't fit perfectly in the window (aren't periodic with it)
and have some dangling fragments near each side of the window.
</p>

<p>In different words, our transforms don't always cancel out when they should, they are sliced off at the ends in the wrong place.
If we had an infinite window of time or we tailored the window to be periodic with each measured frequency and the target signal,
all of this noise would cancel out and leave a pure spike for the probe that fully matches our sinusoid.
</p>

<p>To illustrate the effect, here is an example of <b>2.5Hz</b> wave and a 1-second time window.
  Increasing the time interval changes the spectral resolution and we get a cleaner spike for the target frequency.
  This shape of the frequency spectrum with <cite>side lobes</cite> spreading out is known as the <b>sinc</b> function (in this case, it's absolute, ie |sinc|).
</p>

<figure id="example-6" class="example-plot example-inset-40"><!-- interactive demo --></figure>

<label><small>Time window</small></label>
<select id="example-6-select">
  <option value="1">1s</option>
  <option value="5">5s</option>
  <option value="10">10s</option>
  <option value="30">30s</option>
</select>

<script>(() => {
  const signal = sinusoid(2.5)
  const step = 0.01

  const plot = createLinePlot({step, domain: [0, 30]})
  document.querySelector('#example-6').appendChild(plot.svg.node())

  const freqPlot = createAreaPlot({domain: [0, 5]})
  document.querySelector('#example-6').appendChild(freqPlot.svg.node())

  const sizeInput = document.getElementById('example-6-select')

  const drawExample = () => {
    const size = Number(sizeInput.value)
    const range = d3.range(0, size+step, step)
    plot.update({domain: [0, size], func: signal})
    freqPlot.update({func: analysis(range, signal)})
  }

  d3.select(sizeInput).on('change', drawExample)
  drawExample()

})()</script>

<h4 id="periodic-window-and-frayed-ends">
  <a href="#periodic-window-and-frayed-ends">Periodic window & frayed ends</a>
</h4>

<p>We can demonstrate this requirement to have a periodic window of time in the following interactive example.</p>
<p>
  There is a 2Hz target sine wave and a 4Hz sine probe. The time interval can be increased in increments of 0.125s
  or half of the probe's period.
  Notice how when the window size is periodic with the sine transform, we get a perfect cancellation.
  This is the behavior we want, our 4Hz probe isn't supposed to give a match for the 2Hz target signal.
  We get partial matches when the probe sine does not perfectly fit in the window (isn't periodic with it).
</p>
<p>This is where those lobes and the <i>sinc</i> shape come from.
Note that for higher frequencies these fragments are smaller and have less effect on the transform,
causing smaller spectrum lobes.</p>

<figure id="example-7" class="example-plot"><!-- interactive demo --></figure>


<div class="range-slider">
  <label style="width:120px"><small>Time window</small></label>
  <input id="example-7-time" type="range" min="1" max="2" value="1" step="0.125"></input>
  <output id="example-7-time-label"></output>
</div>

<div class="range-slider">
  <label style="width:120px"><small>Probe frequency</small></label>
  <input id="example-7-freq" type="range" min="1" max="8" value="4" step="1"></input>
  <output id="example-7-freq-label"></output>
</div>
<p>
  <output id="example-7-result"></output>
</p>


<script>(() => {
  const targetSignal = sinusoid(2)
  const margin = 25
  const width = 800
  const height = 250
  const svg = createSVG(width, height)
  const g = svg.insert('g')
    .attr('transform', `translate(0, 30)`)

  const targetPath = g.insert('path')
    .attr('fill', 'none')
    .attr('stroke', '#29B6F6')
    .attr('stroke-width', 2.5)

  const sinePath = svg.insert('g')
    .attr('transform', `translate(0, 90)`)
    .insert('path')
      .attr('fill', 'none')
      .attr('stroke', '#E91E63')
      .attr('stroke-width', 1.5)
      .attr('vector-effect', 'non-scaling-stroke')

  const sineTransformPath = svg.insert('path', 'g')
    .attr('transform', `translate(0, 180)`)
    .attr('fill', '#B0BEC5')

  const fragmentPath = svg.insert('path', 'g')
    .attr('transform', `translate(0, 180)`)
    .attr('fill', '#FFE0B2')

  const bottomAxis = svg.append('g')
    .attr('transform', `translate(0, 160)`)


  document.querySelector('#example-7').appendChild(svg.node())

  const timeInput = document.getElementById('example-7-time')
  const timeLabel = document.getElementById('example-7-time-label')
  const freqInput = document.getElementById('example-7-freq')
  const freqLabel = document.getElementById('example-7-freq-label')

  const line = d3.line().curve(d3.curveNatural)
  const area = d3.area().curve(d3.curveNatural)
  const y = d3.scaleLinear().domain([1, -1]).range([0, 50])
  const x = d3.scaleLinear().range([margin, width-margin])

  const axisScale = d3.scaleLinear().range([margin, width-margin])

  const draw = () => {
    const size = Number(timeInput.value)
    const freq = Number(freqInput.value)

    const sine = sinusoid(freq)

    const periods = size * freq
    timeLabel.innerText = `${size}s (${periods} periods)`
    freqLabel.innerText = `${freq}Hz`

    const domain = [0, size]
    const range = d3.range(domain[0], domain[1]+0.01, 0.01)

    const targetData = range.map((d) => [d, targetSignal(d)])
    const sineData = range.map((d) => [d, sine(d)])
    const sineTransformData = range.map((d, i) => [d, sineData[i][1] * targetData[i][1]])

    x.domain(domain)

    line.x((d) => x(d[0])).y((d) => y(d[1]))
    area.x((d) => x(d[0])).y0(y(0)).y1((d) => y(d[1]))

    bottomAxis.call(d3.axisBottom(x).ticks())
    targetPath.attr('d', line(targetData))
    sinePath.attr('d', line(sineData))
    sineTransformPath.attr('d', area(sineTransformData))

    // find non-periodic fragment at the end
    const fragmentLength = (size % 0.25)

    const fragmentData = d3.range(domain[1] - fragmentLength, domain[1] + 0.01, 0.01)
      .map((d) => [d, sine(d) * targetSignal(d)])
    fragmentPath.attr('d', area(fragmentData))

    const result = d3.fsum(sineTransformData.map(d => d[1]))
    document.querySelector('#example-7-result').innerText = `Result: ${result.toFixed(2)}`
  }
  draw()

  d3.selectAll([timeInput, freqInput]).on('input', draw)

})()</script>

<h4 id="complex-numbers">
  <a href="#complex-numbers">Complex numbers</a>
</h4>
<p>How do complex numbers come into play? </p>

<p>There is a common way to write down the Fourier transform for frequency <i>s</i> that uses complex numbers:
 $$F_s = \int_{-\infty}^\infty f(t)\cdot(\cos(2πst) - i \cdot\sin(2πst))dt$$</p>

<p>From my understanding, it's just a convenient way to write sine & cosine components in a single math expression.
  Multiplying the sine transform with the imaginary number separates it from the cosine component,
  since real & imaginary numbers don't mix.
</p>

<p>
  Another common notation uses <a href="https://en.wikipedia.org/wiki/Euler%27s_identity">Euler's identity</a>:
  $$e^{ix} = \cos{x} + i\sin{x}$$

  which gives us this beautiful condensed version:
  $$F_s = \int_{-\infty}^\infty f(t)\cdot e^{-i2πst}dt$$
</p>

<h4 id="conclusion">
  <a href="#conclusion">Conclusion</a>
</h4>


<p>
We can analyze frequencies in any waveform by multiplying it with other periodic waves for each of the frequencies we want to find.
These analysis waveforms, aka <q>probes</q> must have some parts above zero and some below zero so their sum averages to zero.
Sines and cosines are good candidates, the combination of these two transforms is sufficient to detect a
frequency regardless of where it is positioned in the wave, ie its phase (or even its duration).
But they exhibit issues when analyzing limited time intervals, since they don't taper off and instead extend to infinity.
</p>

<hr>

<footer>
<p>Copyright &copy; Davorin Šego</p>
<p>
  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
  <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
  <br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</p>
</footer>

</body>
</html>
